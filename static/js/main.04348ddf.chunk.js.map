{"version":3,"sources":["components/CodeEditor/examplesMap.tsx","components/CodeEditor/examples/factorial.tig","components/CodeEditor/examples/stringConcat.tig","components/CodeEditor/examples/basicArray.tig","components/CodeEditor/examples/fizzbuzz.tig","components/CodeEditor/examples/bubbleSort.tig","components/CodeEditor/examples/queens.tig","components/CodeEditor/Examples.tsx","components/CodeEditor/CodeEditor.tsx","hooks/useCtrlKeys.ts","components/ASTViewer/ASTViewer.tsx","utils/cleanAst.ts","components/TREEViewer/TREEViewer.tsx","components/CanonViewer/CanonViewer.tsx","components/CustomConsole/CustomConsole.tsx","hooks/useConsole.ts","interpreter/utils/utils.ts","interpreter/frame.ts","interpreter/utils/stmPatterns.ts","interpreter/utils/treeUtils.ts","interpreter/utils/fragPatterns.ts","interpreter/utils/expPatterns.ts","utils/runtimeUtils.ts","evaluator/memoryManager.ts","utils/utils.ts","interpreter/utils/memMap.ts","interpreter/utils/stringStorage.ts","interpreter/runtime.ts","interpreter/interpreter.ts","components/Interpreter/InterpreterOk.tsx","hooks/useInterpreter.ts","components/Interpreter/Interpreter.tsx","evaluator/stringStorage.ts","evaluator/asyncify.js","evaluator/runtime.ts","evaluator/evaluator.ts","components/Evaluator/EvaluatorOk.tsx","hooks/useEvaluator.ts","components/Evaluator/ErrorBoundary.tsx","components/Evaluator/Evaluator.tsx","components/Tabs/Tab.tsx","components/Tabs/Tabs.tsx","hooks/useCtrlAltKeys.ts","components/WASMViewer/WASMViewer.tsx","hooks/useWatFromWasm.ts","hooks/useCompileResult.ts","hooks/useLocalStorageState.ts","utils/baseCode.ts","components/Compiler/CompilerInterface.tsx","components/Compiler/Compiler.tsx","components/Header/Header.tsx","components/Footer.tsx/Footer.tsx","App.tsx","index.tsx"],"names":["EXAMPLES","Examples","setCode","compileCode","className","Object","entries","map","fileName","content","key","ExampleItem","onClick","CodeEditor","compileKeyCodes","handler","code","useEffect","keyHandler","e","includes","keyCode","ctrlKey","preventDefault","document","addEventListener","removeEventListener","mode","theme","onChange","newCode","value","name","editorProps","$blockScrolling","style","height","fontSize","width","showPrintMargin","onLoad","editor","focus","onBlur","ASTViewer","props","ast","OkASTViewer","useState","cleanType","cleanPosition","cleanNode","cleanEscape","options","setOptions","prettyAst","useMemo","cleanAst","Array","isArray","keys","forEach","k","nodeName","elem","isValidAst","length","src","enableClipboard","displayObjectSize","displayDataTypes","CleanControls","collapsed","setCollapsed","optionsClassName","option","id","type","checked","htmlFor","TREEViewer","fragments","undefined","Err","OkTREEViewer","CanonViewer","canon","OkCanonViewer","CustomConsole","messages","isReading","isReadingChar","customConsole","consoleRef","useRef","element","current","scrollTop","scrollHeight","ref","msg","index","MessageWithPrompt","message","children","ConsoleInput","setMessage","autoFocus","event","target","onKeyPress","resolveRead","spellCheck","ConsoleCharInput","illegalResolve","str","Error","useConsole","setMessages","setIsReading","setIsReadingChar","clear","_oldMessages","print","oldMessages","newMessages","concat","replace","printLine","read","Promise","resolve","readChar","char","UnexpectedUndefinedError","UnreachableError","assertExists","assertCondition","condition","IncludeMap","set","foundIndex","findIndex","entry","push","get","maybeEntry","find","this","accessExpFromFormal","formal","LOCAL","inLocalAccessExp","accessExpsFromFormals","formals","isExpStm","stm","isMoveStm","isJumpStm","isCjumpStm","isSeqStm","isLabelStm","findLabelIndex","stms","label","LABEL","flatStms","fragStms","fragStm","evalBinop","op","leftVal","rightVal","Math","floor","Number","isFunFrag","fragment","isStringFrag","isConstExp","exp","isNameExp","isLocalExp","isGlobalExp","isBinopExp","isMemExp","isCallExp","isEseqExp","RuntimeExit","exitCode","OutOfBoundsException","pointer","NilPointerException","HEAP_START","MEMORY_PAGES","HEAP_END","ASYNCIFY_DATA_START","MemoryManager","memory","allocatedSizes","nextFreeIndex","alloc","bytes","checkArrayIndex","byteCount","wordStore","dir","wordAssertRange","wordGet","byteStore","byteAssertRange","byteGet","wordDebugSlice","start","count","values","i","console","log","byteDebugSlice","String","fromCharCode","Map","MemMap","nextFreeMem","nextFree","StringStorage","memMap","labelMap","strings","storeString","stringFrag","ConstString","addr","storeUnlabeledString","loadString","Runtime","stringStorage","nameMap","arraySizes","getFunction","maybeGetFunction","args","strPointer","flush","getchar","a","getstring","ord","charCodeAt","chr","charCode","size","substring","slicedStr","slice","leftStrPointer","rightStrPointer","newStr","not","debugWords","words","itemLocation","debugBytes","allocArray","init","arrayLocation","checkIndexArray","checkNil","record","allocRecord","strEquals","comparison","strCompare","strNotEquals","strLess","strLessOrEquals","strGreater","strGreaterOrEquals","leftStr","rightStr","localeCompare","debug_words","debug_bytes","TreeInterpreter","locals","globals","labels","mem","functions","runtime","run","evalFunction","Proc","body","frame","localsToRestore","prevFp","setupFormals","execStms","rv","executedStmIndex","evalStm","maybeLabel","nextStmIndex","accessExps","arg","access","GLOBAL","evalExp","EXP","MOVE","toExp","fromExp","MEM","location","JUMP","where","NAME","CJUMP","leftExp","rightExp","labelTrue","labelFalse","CONST","BINOP","CALL","labelExp","all","evaluatedArgs","runtimeFunction","returnValue","filter","frag","InterpreterOk","frags","isRunning","setIsRunning","interpreter","useCallback","result","error","useInterpreter","disabled","RunButton","Interpreter","InterpreterErr","memoryManager","readString","string","encodedChar","writeString","WRAPPED_EXPORTS","WeakMap","isPromise","obj","then","proxyGet","transform","Proxy","Asyncify","dataAddr","dataEnd","dataStart","state","exports","fn","asyncify_stop_rewind","assertNoneState","asyncify_start_unwind","promise","module","wrapImportFn","imports","moduleImports","wrapModuleImports","newExport","asyncify_stop_unwind","asyncify_start_rewind","newExports","create","exportName","startsWith","wrapExportFn","defineProperty","enumerable","instance","Int32Array","buffer","wrapExports","setPrototypeOf","Instance","prototype","wrapImports","WebAssembly","instantiate","source","binary","instanceImports","wasmInstance","main","tigermain_wrapper","execution","end","slicedString","str1Pointer","str2Pointer","str1","str2","exit","alloc_array","alloc_record","check_index_array","check_nil","str_equals","str_not_equals","str_less","str_less_or_equals","str_greater","str_greater_or_equals","Memory","initial","maximum","Uint8Array","externals","WasmEvaluator","binaryWasm","wasmModule","binaryen","readBinary","setOptimizeLevel","runPasses","emitBinary","EvaluatorOk","bin","evaluator","from","useEvaluator","ErrorBoundary","errorInfo","fallback","React","Component","Evaluator","EvaluatorError","Tab","Tabs","selectedIndex","setSelectedIndex","names","Children","child","anyChild","isNil","visibleTab","toArray","TabsButtons","TabButton","selectedClass","moveToTab","altKey","WASMViewer","wat","emitText","useWatFromWasm","useCompileResult","compile","initialValue","item","window","localStorage","getItem","JSON","parse","storedValue","setStoredValue","setValue","valueToStore","Function","setItem","stringify","warn","useLocalStorageState","typecheck","escape","translate","wasm","compileResult","setCompileResult","lastCompiledCode","setLastCompiledCode","err","CompilerInterface","AsyncCompiler","lazy","default","Compiler","Header","Footer","Blood","role","aria-label","Rage","IvoLink","href","rel","FedeLink","App","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.04348ddf.chunk.js","sourcesContent":["import factorial from './examples/factorial.tig';\nimport stringConcat from './examples/stringConcat.tig';\nimport basicArray from './examples/basicArray.tig';\nimport fizzBuzz from './examples/fizzbuzz.tig';\nimport bubbleSort from './examples/bubbleSort.tig';\nimport queens from './examples/queens.tig';\n\ninterface ExamplesByName {\n    [name: string]: string;\n}\n\nexport const EXAMPLES: ExamplesByName = {\n    'factorial.tig': factorial,\n    'stringConcat.tig': stringConcat,\n    'basicArray.tig': basicArray,\n    'fizzBuzz.tig': fizzBuzz,\n    'bubbleSort.tig': bubbleSort,\n    'queens.tig': queens,\n};\n","export default \"let\\n    function fact (n : int) : int =\\n        if  n = 0\\n            then 1\\n            else n * fact (n - 1)\\nin\\n    fact (5)\\nend\\n\";","export default \"let\\n    var mila := \\\"mila\\\"\\n    var nesa := \\\"nesa\\\"\\n    var milanesa := concat(mila, nesa)\\nin\\n    print(milanesa); 0\\nend\";","export default \"let\\n    type intarray = array of int\\n    var arr1: intarray := intarray [10] of 5\\nin\\n    arr1[5] := 42;\\n    arr1[5]\\nend\\n\";","export default \"let\\n    function mod(i: int, c: int) : int =\\n        i - (i / c) * c = 0\\n\\n    function printdigit (i : int) = (\\n        print(chr(ord(\\\"0\\\") + i))\\n    )\\n\\n    function printint (i : int) = (\\n        if i < 10 then (\\n            printdigit(i)\\n        ) else (\\n            printint(i / 10);\\n            printdigit(i - (i / 10) * 10)\\n        )\\n    )\\n\\n    function FizzBuzz() = (\\n        for i := 1 to 100 do (\\n            if mod(i, 3) & mod(i, 5) then\\n                print(\\\"FizzBuzz\\\\n\\\")\\n            else if mod(i, 3) then\\n                print(\\\"Fizz\\\\n\\\")\\n            else if mod(i, 5) then\\n                print(\\\"Buzz\\\\n\\\")\\n            else\\n                (printint(i); print(\\\"\\\\n\\\"))\\n        )\\n    )\\nin\\n    (FizzBuzz(); 0)\\nend\";","export default \"let\\n    function writedigit(i : int): string = (\\n        chr(ord(\\\"0\\\") + i)\\n    )\\n\\n    function writeint(i : int): string = (\\n        if i < 10 then (\\n            writedigit(i)\\n        ) else (\\n            concat(\\n                writeint(i / 10),\\n                writedigit(i - (i / 10) * 10)\\n            )\\n        )\\n    )\\n\\n    function printint(i: int) = (\\n        print(writeint(i))\\n    )\\n\\n    function readdigit(s: string): int = (\\n        ord(s) - ord(\\\"0\\\")\\n    )\\n\\n    function readint(s: string): int = (\\n        let\\n            var strSize := size(s)\\n        in\\n            if strSize = 1 then (\\n                readdigit(s)\\n            ) else (\\n                readint(substring(s, 0, strSize - 1)) * 10 +\\n                readdigit(substring(s, strSize - 1, strSize))\\n            )\\n        end\\n    )\\n\\n    var arrSize := (\\n        print(\\\"Enter array size:\\\");\\n        readint(getstring())\\n    )\\n\\n    type intarray = array of int\\n    var arr: intarray := intarray [arrSize] of 0\\n\\n    function readArray() = (\\n        (for r := 0 to (arrSize - 1) do (\\n            print(concat(\\\"enter element \\\", writeint(r)));\\n            arr[r] := readint(getstring())\\n        ))\\n    )\\n\\n    function printArray() = (\\n        print(\\\"[\\\");\\n        (for i := 0 to (arrSize - 1) do (\\n            printint(arr[i]);\\n            if i <> (arrSize - 1) then print(\\\", \\\")\\n        ));\\n        print(\\\"]\\\")\\n    )\\n\\n    function swap(pos1: int, pos2: int) = (\\n        let\\n            var temp := arr[pos1]\\n        in\\n            arr[pos1] := arr[pos2];\\n            arr[pos2] := temp\\n        end\\n    )\\n\\n    function sortArray() = (\\n        (for i := 0 to (arrSize - 1) do (\\n            (for j := 0 to (arrSize - 2 - i) do (\\n                if arr[j] > arr[j + 1] then (\\n                    swap(j, j + 1)\\n                )\\n            ))\\n        ))\\n    )\\nin\\n    readArray();\\n\\n    print(\\\"\\\\n\\\");\\n    print(\\\"Original array:\\\\n\\\");\\n    printArray();\\n    print(\\\"\\\\n\\\");\\n\\n\\n    print(\\\"\\\\n\\\");\\n    print(\\\"Sorted array:\\\\n\\\");\\n    sortArray();\\n    printArray();\\n    print(\\\"\\\\n\\\");\\n\\n    0\\nend\";","export default \"/* A program to solve the 8-queens problem */\\n\\nlet\\n    var N := 8\\n\\n    type intArray = array of int\\n\\n    var row := intArray [ N ] of 0\\n    var col := intArray [ N ] of 0\\n    var diag1 := intArray [N+N-1] of 0\\n    var diag2 := intArray [N+N-1] of 0\\n\\n    function printboard () =\\n       (for i := 0 to N-1\\n\\t do (for j := 0 to N-1\\n\\t      do print (if col[i]=j then \\\" O\\\" else \\\" .\\\");\\n\\t     print (\\\"\\\\n\\\"));\\n         print (\\\"\\\\n\\\"))\\n\\n    function try (c : int) =\\n( /*  for i := 0 to c do print (\\\".\\\"); print (\\\"\\\\n\\\"); flush ();*/\\n     if c=N\\n     then printboard ()\\n     else (for r := 0 to N-1\\n\\t   do if row[r]=0 & diag1[r+c]=0 & diag2[r+7-c]=0\\n\\t           then (row[r] :=1; diag1[r+c] :=1; diag2[r+7-c] :=1;\\n\\t\\t         col[c] :=r;\\n\\t                 try (c+1);\\n\\t\\t\\t row[r] :=0; diag1[r+c] :=0; diag2[r+7-c] :=0))\\n\\n)\\n in try (0); 0\\nend\\n\";","import React from 'react';\nimport { EXAMPLES } from './examplesMap';\nimport { CompileCodeAction } from '../../hooks/useCompileResult';\n\ninterface ExamplesProps {\n    setCode: React.Dispatch<React.SetStateAction<string>>;\n    compileCode: CompileCodeAction;\n}\n\nexport const Examples: React.FC<ExamplesProps> = ({ setCode, compileCode }) => {\n    return (\n        <div className=\"examples-list-container\">\n            <h3>Examples</h3>\n            <ul className=\"examples-list\">\n                {Object.entries(EXAMPLES).map(([fileName, content]) => {\n                    return (\n                        <ExampleItem\n                            key={fileName}\n                            fileName={fileName}\n                            content={content}\n                            setCode={setCode}\n                            compileCode={compileCode}\n                        />\n                    );\n                })}\n            </ul>\n        </div>\n    );\n};\n\ninterface ExampleItemProps {\n    fileName: string;\n    content: string;\n    setCode: React.Dispatch<React.SetStateAction<string>>;\n    compileCode: CompileCodeAction;\n}\nconst ExampleItem: React.FC<ExampleItemProps> = ({ fileName, content, setCode, compileCode }) => {\n    const onClick = () => {\n        setCode(content);\n        compileCode(content);\n    };\n\n    return (\n        <li>\n            <button onClick={onClick}>{fileName}</button>\n        </li>\n    );\n};\n","import React, { CSSProperties } from 'react';\nimport AceEditor, { IEditorProps } from 'react-ace';\nimport { useCtrlKeys } from '../../hooks/useCtrlKeys';\nimport { Examples } from './Examples';\nimport { CompileCodeAction } from '../../hooks/useCompileResult';\nimport 'ace-builds/src-noconflict/theme-monokai';\nimport 'ace-builds/src-noconflict/mode-golang';\nimport './CodeEditor.scss';\n\ninterface CodeEditorProps {\n    code: string;\n    setCode: React.Dispatch<React.SetStateAction<string>>;\n    compileCode: CompileCodeAction;\n}\n\nexport const CodeEditor: React.FC<CodeEditorProps> = ({ compileCode, code, setCode }) => {\n    useCtrlKeys([13, 83], () => compileCode(code));\n\n    const editorStyles: CSSProperties = {\n        height: '600px',\n        fontSize: '14px',\n        width: '85%',\n    };\n\n    return (\n        <div className=\"code-editor-container\">\n            <Examples setCode={setCode} compileCode={compileCode} />\n            <AceEditor\n                mode=\"golang\"\n                theme=\"monokai\"\n                onChange={(newCode) => setCode(newCode)}\n                value={code}\n                name=\"code-editor\"\n                editorProps={{ $blockScrolling: true }}\n                style={editorStyles}\n                showPrintMargin={false}\n                onLoad={(editor: IEditorProps) => editor.focus()}\n                onBlur={() => compileCode(code)}\n            />\n        </div>\n    );\n};\n","import { useEffect } from 'react';\n\nexport const useCtrlKeys = (compileKeyCodes: number[], handler: () => void): void => {\n    useEffect(() => {\n        const keyHandler = (e: KeyboardEvent): void => {\n            if (compileKeyCodes.includes(e.keyCode) && e.ctrlKey) {\n                handler();\n                e.preventDefault();\n            }\n        };\n\n        document.addEventListener('keydown', keyHandler);\n\n        return () => {\n            document.removeEventListener('keydown', keyHandler);\n        };\n    }, [handler, compileKeyCodes]);\n};\n","import React, { useMemo, useState } from 'react';\nimport ReactJson from 'react-json-view';\nimport { cleanAst, CleanOptions } from '../../utils/cleanAst';\nimport { EscapeResult } from '../Compiler/CompilerInterface';\nimport './ASTViewer.scss';\n\ninterface ASTViewerProps {\n    ast: EscapeResult;\n}\n\nexport const ASTViewer: React.FC<ASTViewerProps> = (props) => {\n    const { ast } = props;\n\n    if (ast === null) {\n        return (\n            <div>\n                <h3>No AST to show!</h3>\n                <p>Did you compile the code?</p>\n                <p>If so, check the WASM results to see if there were any errors</p>\n            </div>\n        );\n    } else {\n        return <OkASTViewer ast={ast} />;\n    }\n};\n\nconst OkASTViewer: React.FC<ASTViewerProps> = (props) => {\n    const { ast } = props;\n\n    const [options, setOptions] = useState<CleanOptions>({\n        cleanType: true,\n        cleanPosition: true,\n        cleanNode: true,\n        cleanEscape: true,\n    });\n\n    const prettyAst = useMemo(() => cleanAst(ast, options), [ast, options]);\n\n    // An AST is valid if it has at least one key\n    const isValidAst = Object.keys(prettyAst).length > 0;\n\n    return (\n        <div className=\"ast-viewer\">\n            <ReactJson\n                src={prettyAst}\n                theme=\"monokai\"\n                enableClipboard={false}\n                displayObjectSize={false}\n                displayDataTypes={false}\n            />\n            {isValidAst && <CleanControls options={options} setOptions={setOptions} />}\n        </div>\n    );\n};\n\ninterface CleanControlsProps {\n    options: CleanOptions;\n    setOptions: React.Dispatch<React.SetStateAction<CleanOptions>>;\n}\n\nconst CleanControls: React.FC<CleanControlsProps> = ({ options, setOptions }) => {\n    const [collapsed, setCollapsed] = useState<boolean>(true);\n    const toggleCollapse = () => setCollapsed(!collapsed);\n\n    const optionsClassName = `options-container ${collapsed ? 'collapsed' : 'expanded'}`;\n\n    return (\n        <div className=\"clean-controls-container\">\n            <button className=\"collapse-button\" onClick={toggleCollapse}>\n                {collapsed ? 'Options' : 'Collapse'}\n            </button>\n            <div className={optionsClassName}>\n                {Object.entries(options).map(([option, value]) => {\n                    const onChange = () => setOptions({ ...options, [option]: !value });\n                    return (\n                        <div className=\"option-checkbox\" key={option}>\n                            <input\n                                id={option}\n                                type=\"checkbox\"\n                                checked={value}\n                                onChange={onChange}\n                            />\n                            <label htmlFor={option}>{option}</label>\n                        </div>\n                    );\n                })}\n            </div>\n        </div>\n    );\n};\n","export interface CleanOptions {\n    cleanType?: boolean;\n    cleanPosition?: boolean;\n    cleanNode?: boolean;\n    cleanEscape?: boolean;\n}\n\nexport const cleanAst = (ast: any, options: CleanOptions = {}): any => {\n    const {\n        cleanType = true,\n        cleanPosition = true,\n        cleanNode = true,\n        cleanEscape = true,\n    } = options;\n\n    // If it's a json\n    if (typeof ast === 'object' && !Array.isArray(ast) && ast !== null) {\n        const prettyAst: any = {};\n\n        Object.keys(ast).forEach((k) => {\n            // Clean nodes if necessary\n            if (k === 'node' && cleanNode) {\n                const nodeName = Object.keys(ast['node'])[0];\n                prettyAst[nodeName] = cleanAst(ast['node'][nodeName], options);\n                return;\n            }\n\n            // Clean position if necessary\n            if (k === 'pos' && cleanPosition) {\n                return;\n            }\n\n            // Clean type if necessary\n            if (k === 'typ' && cleanType) {\n                return;\n            }\n\n            // Clean escapes if necessary\n            if (k === 'escape' && cleanEscape) {\n                return;\n            }\n\n            prettyAst[k] = cleanAst(ast[k], options);\n        });\n\n        return prettyAst;\n    }\n\n    // If it's an array\n    if (typeof ast === 'object' && Array.isArray(ast)) {\n        return ast.map((elem) => cleanAst(elem, options));\n    }\n\n    // If it's not an object/array don't modify it.\n    return ast;\n};\n","import React from 'react';\nimport ReactJson from 'react-json-view';\nimport { TranslateResult } from '../Compiler/CompilerInterface';\n\ninterface TREEViewerProps {\n    fragments: TranslateResult;\n}\n\nexport const TREEViewer: React.FC<TREEViewerProps> = (props) => {\n    const { fragments } = props;\n\n    if (fragments === null) {\n        return (\n            <div>\n                <h3>No fragments to show!</h3>\n                <p>Did you compile the code?</p>\n                <p>If so, check the WASM results to see if there were any errors</p>\n            </div>\n        );\n    } else if (fragments.Err !== undefined) {\n        return (\n            <div>\n                <h3>No fragments to show!</h3>\n                <p>check the WASM results, it seems there was an error translating</p>\n            </div>\n        );\n    } else {\n        return <OkTREEViewer fragments={fragments} />;\n    }\n};\n\nexport const OkTREEViewer: React.FC<TREEViewerProps> = (props) => {\n    // We're sure this is NOT null\n    const { fragments } = props;\n\n    return (\n        <div className=\"tree-viewer\">\n            <ReactJson\n                src={fragments as any}\n                theme=\"monokai\"\n                enableClipboard={false}\n                displayObjectSize={false}\n                displayDataTypes={false}\n            />\n        </div>\n    );\n};\n","import React from 'react';\nimport ReactJson from 'react-json-view';\nimport { CanonResult } from '../Compiler/CompilerInterface';\n\ninterface CanonViewerProps {\n    canon: CanonResult | null;\n}\n\nexport const CanonViewer: React.FC<CanonViewerProps> = (props) => {\n    const { canon } = props;\n\n    if (canon === null) {\n        return (\n            <div>\n                <h3>No fragments to show!</h3>\n                <p>Did you compile the code?</p>\n                <p>If so, check the WASM results to see if there were any errors</p>\n            </div>\n        );\n    } else {\n        return <OkCanonViewer canon={canon} />;\n    }\n};\n\nexport const OkCanonViewer: React.FC<CanonViewerProps> = (props) => {\n    // We're sure this is NOT null\n    const { canon } = props;\n\n    return (\n        <div className=\"canon-viewer\">\n            <ReactJson\n                src={canon as any}\n                theme=\"monokai\"\n                enableClipboard={false}\n                displayObjectSize={false}\n                displayDataTypes={false}\n            />\n        </div>\n    );\n};\n","import React, { useState, useRef, useEffect } from 'react';\nimport { UserConsole } from '../../hooks/useConsole';\n\nimport './CustomConsole.scss';\n\nconst prompt = '>';\n\ninterface CustomConsoleProps {\n    customConsole: UserConsole;\n    messages: string[];\n    isReading: boolean;\n    isReadingChar: boolean;\n}\n\nexport const CustomConsole: React.FC<CustomConsoleProps> = (props) => {\n    const { messages, isReading, isReadingChar, customConsole } = props;\n\n    const consoleRef = useRef<HTMLDivElement | null>(null);\n    useEffect(() => {\n        const element = consoleRef.current;\n        if (element !== null) {\n            element.scrollTop = element.scrollHeight;\n        }\n    });\n\n    return (\n        <div className=\"custom-console\" ref={consoleRef}>\n            {messages.map((msg: string, index: number) => {\n                return <MessageWithPrompt key={index}>{msg}</MessageWithPrompt>;\n            })}\n            {isReading && <ConsoleInput customConsole={customConsole} />}\n            {isReadingChar && <ConsoleCharInput customConsole={customConsole} />}\n        </div>\n    );\n};\n\ninterface MessageWithPromptProps {\n    children: string;\n}\n\nconst MessageWithPrompt: React.FC<MessageWithPromptProps> = (props) => {\n    const message = props.children;\n\n    return (\n        <div className=\"message-with-prompt\">\n            <span className=\"prompt\">{prompt}</span>\n            <pre className=\"message\">{message}</pre>\n        </div>\n    );\n};\n\ninterface ConsoleInputProps {\n    customConsole: UserConsole;\n}\n\nconst ConsoleInput: React.FC<ConsoleInputProps> = (props) => {\n    const [message, setMessage] = useState('');\n\n    const onChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        const { value } = event.target;\n\n        setMessage(value);\n    };\n\n    const onKeyPress = (event: React.KeyboardEvent<HTMLInputElement>) => {\n        const { key } = event;\n\n        if (key === 'Enter') {\n            props.customConsole.resolveRead(message);\n        }\n    };\n\n    return (\n        <div className=\"message-with-prompt\">\n            <span className=\"prompt\">{prompt}</span>\n            <input\n                className=\"input\"\n                autoFocus={true}\n                onChange={onChange}\n                value={message}\n                onKeyPress={onKeyPress}\n                spellCheck={false}\n            />\n        </div>\n    );\n};\n\nconst ConsoleCharInput: React.FC<ConsoleInputProps> = (props) => {\n    const [message, setMessage] = useState<string>('');\n    const onChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        const { value } = event.target;\n        setMessage(value);\n\n        if (value.length >= 1) {\n            props.customConsole.resolveRead(value[0]);\n        }\n    };\n\n    return (\n        <div className=\"message-with-prompt\">\n            <span className=\"prompt\">{prompt}</span>\n            <input\n                className=\"input\"\n                autoFocus={true}\n                onChange={onChange}\n                value={message}\n                spellCheck={false}\n            />\n        </div>\n    );\n};\n","import { CustomConsole } from '../utils/console';\nimport { useState, useMemo } from 'react';\n\nexport interface UserConsole extends CustomConsole {\n    clear: () => void;\n    resolveRead: (str: string) => void;\n    printLine: (str: string) => void;\n}\n\nconst illegalResolve = (str: string): void => {\n    throw new Error('Cannot resolve a string if not reading!');\n};\n\nexport const useConsole = (): [UserConsole, string[], boolean, boolean] => {\n    const [messages, setMessages] = useState<string[]>(['']);\n\n    const [isReading, setIsReading] = useState<boolean>(false);\n\n    const [isReadingChar, setIsReadingChar] = useState<boolean>(false);\n\n    const hookConsole = useMemo(() => {\n        class HookConsole implements UserConsole {\n            resolveRead: (str: string) => void = illegalResolve;\n\n            clear = () => {\n                setMessages((_oldMessages) => ['']);\n            };\n\n            print = (str: string) => {\n                setMessages((oldMessages) => {\n                    const newMessages = [...oldMessages];\n\n                    newMessages[newMessages.length - 1] = newMessages[\n                        newMessages.length - 1\n                    ].concat(str.replace(/\\\\n/g, '\\n'));\n\n                    return newMessages;\n                });\n            };\n\n            printLine = (str: string) => {\n                setMessages((oldMessages) => [...oldMessages, str]);\n            };\n\n            read = () => {\n                return new Promise<string>((resolve) => {\n                    setIsReading(true);\n\n                    this.resolveRead = (str: string) => {\n                        setMessages((oldMessages) => [...oldMessages, str, '']);\n                        setIsReading(false);\n\n                        // Send this value over to the console consumer\n                        resolve(str);\n                    };\n                });\n            };\n\n            readChar = () => {\n                return new Promise<string>((resolve) => {\n                    setIsReadingChar(true);\n\n                    this.resolveRead = (str: string) => {\n                        const char = str[0];\n                        setMessages((oldMessages) => [...oldMessages, char, '']);\n                        setIsReadingChar(false);\n\n                        // Send this value over to the console consumer\n                        resolve(char);\n                    };\n                });\n            };\n        }\n\n        return new HookConsole();\n    }, []);\n\n    return [hookConsole, messages, isReading, isReadingChar];\n};\n","export class NotImplementedError extends Error {\n    constructor() {\n        super('Not implemented!');\n    }\n}\n\nexport class UnexpectedUndefinedError extends Error {\n    constructor(msg?: string) {\n        super(msg ?? 'Unexpected undefined value!');\n    }\n}\n\nexport class UnreachableError extends Error {\n    constructor(msg?: string) {\n        super(msg ?? 'Unreachable branch');\n    }\n}\n\nexport const assertExists = <T>(value: T | undefined, msg?: string): T => {\n    if (value === undefined) {\n        throw new UnexpectedUndefinedError(msg);\n    } else {\n        return value;\n    }\n};\n\nexport const assertCondition = (condition: boolean, msg: string): void => {\n    if (!condition) {\n        throw new Error(msg);\n    }\n};\n\ninterface IncludeMapEntry<K, V> {\n    key: K;\n    value: V;\n}\n\nexport class IncludeMap<V> {\n    entries: IncludeMapEntry<string, V>[];\n\n    constructor() {\n        this.entries = [];\n    }\n\n    set = (key: string, value: V): IncludeMap<V> => {\n        const foundIndex = this.entries.findIndex((entry): boolean => entry.key.includes(key));\n\n        if (foundIndex >= 0) {\n            this.entries[foundIndex] = { key, value };\n        } else {\n            this.entries.push({ key, value });\n        }\n\n        return this;\n    };\n\n    get = (key: string): V | undefined => {\n        const maybeEntry = this.entries.find((entry): boolean => entry.key.includes(key));\n\n        if (maybeEntry === undefined) {\n            return undefined;\n        } else {\n            return maybeEntry.value;\n        }\n    };\n}\n","import { Exp } from './treeTypes';\n\nconst inLocalAccessExp = (name: string): Exp => ({\n    LOCAL: name,\n});\n\n// For now, all formals go in memory\nconst accessExpFromFormal = (formal: [string, boolean]): Exp => {\n    const [name] = formal;\n    return inLocalAccessExp(name);\n};\n\nexport const accessExpsFromFormals = (formals: [string, boolean][]): Exp[] => {\n    return formals.map(accessExpFromFormal);\n};\n","import { Stm, LabelStm, ExpStm, MoveStm, JumpStm, CjumpStm, SeqStm } from '../treeTypes';\n\nexport const isExpStm = (stm: Stm): stm is ExpStm => {\n    return 'EXP' in stm;\n};\n\nexport const isMoveStm = (stm: Stm): stm is MoveStm => {\n    return 'MOVE' in stm;\n};\n\nexport const isJumpStm = (stm: Stm): stm is JumpStm => {\n    return 'JUMP' in stm;\n};\n\nexport const isCjumpStm = (stm: Stm): stm is CjumpStm => {\n    return 'CJUMP' in stm;\n};\n\nexport const isSeqStm = (stm: Stm): stm is SeqStm => {\n    return 'SEQ' in stm;\n};\n\nexport const isLabelStm = (stm: Stm): stm is LabelStm => {\n    return 'LABEL' in stm;\n};\n","import { Label, Stm, BinOp, FragStm } from '../treeTypes';\nimport { isLabelStm } from './stmPatterns';\nimport { UnreachableError } from './utils';\n\nexport const findLabelIndex = (stms: Stm[], label: Label): number => {\n    const foundIndex = stms.findIndex((stm) => {\n        return isLabelStm(stm) && stm.LABEL === label;\n    });\n\n    if (foundIndex === -1) {\n        throw new Error(`Could not find label '${label}'!`);\n    }\n\n    return foundIndex;\n};\n\nexport const flatStms = (fragStms: FragStm[]): Stm[] => {\n    const stms: Stm[] = [];\n\n    fragStms.forEach((fragStm) => {\n        stms.push(...fragStm.stms);\n    });\n\n    return stms;\n};\n\nexport const evalBinop = (op: BinOp, leftVal: number, rightVal: number): number => {\n    switch (op) {\n        case 'PLUS':\n            return leftVal + rightVal;\n\n        case 'MINUS':\n            return leftVal - rightVal;\n\n        case 'MUL':\n            return leftVal * rightVal;\n\n        case 'DIV':\n            return Math.floor(leftVal / rightVal);\n\n        case 'AND':\n            return leftVal && rightVal;\n\n        case 'OR':\n            return leftVal || rightVal;\n\n        case 'LSHIFT':\n            return leftVal << rightVal;\n\n        case 'RSHIFT':\n            return leftVal >>> rightVal;\n\n        case 'ARSHIFT':\n            return leftVal >> rightVal;\n\n        case 'XOR':\n            return leftVal ^ rightVal;\n\n        case 'EQ':\n            return Number(leftVal === rightVal);\n\n        case 'NE':\n            return Number(leftVal !== rightVal);\n\n        case 'LT':\n            return Number(leftVal < rightVal);\n\n        case 'GT':\n            return Number(leftVal > rightVal);\n\n        case 'LE':\n            return Number(leftVal <= rightVal);\n\n        case 'GE':\n            return Number(leftVal >= rightVal);\n\n        case 'ULT':\n            // Not sure, our parser doesn't even generate this\n            return Number(leftVal < rightVal);\n\n        case 'ULE':\n            // Not sure, our parser doesn't even generate this\n            return Number(leftVal <= rightVal);\n\n        case 'UGT':\n            // Not sure, our parser doesn't even generate this\n            return Number(leftVal > rightVal);\n\n        case 'UGE':\n            // Not sure, our parser doesn't even generate this\n            return Number(leftVal >= rightVal);\n\n        default:\n            throw new UnreachableError();\n    }\n};\n","import { Frag, FunFrag, StringFrag } from '../treeTypes';\n\nexport const isFunFrag = (fragment: Frag): fragment is FunFrag => {\n    return 'Proc' in fragment;\n};\n\nexport const isStringFrag = (fragment: Frag): fragment is StringFrag => {\n    return 'ConstString' in fragment;\n};\n","import {\n    Exp,\n    MemExp,\n    LocalExp,\n    ConstExp,\n    NameExp,\n    BinopExp,\n    CallExp,\n    EseqExp,\n    GlobalExp,\n} from '../treeTypes';\n\nexport const isConstExp = (exp: Exp): exp is ConstExp => {\n    return 'CONST' in exp;\n};\n\nexport const isNameExp = (exp: Exp): exp is NameExp => {\n    return 'NAME' in exp;\n};\n\nexport const isLocalExp = (exp: Exp): exp is LocalExp => {\n    return 'LOCAL' in exp;\n};\n\nexport const isGlobalExp = (exp: Exp): exp is GlobalExp => {\n    return 'GLOBAL' in exp;\n};\n\nexport const isBinopExp = (exp: Exp): exp is BinopExp => {\n    return 'BINOP' in exp;\n};\n\nexport const isMemExp = (exp: Exp): exp is MemExp => {\n    return 'MEM' in exp;\n};\n\nexport const isCallExp = (exp: Exp): exp is CallExp => {\n    return 'CALL' in exp;\n};\n\nexport const isEseqExp = (exp: Exp): exp is EseqExp => {\n    return 'ESEQ' in exp;\n};\n","export class RuntimeExit {\n    constructor(readonly exitCode: number) {}\n}\n\nexport class OutOfBoundsException extends Error {\n    constructor(readonly index: number, readonly pointer: number) {\n        super(`Cannot access pointer ${pointer} at index ${index}`);\n    }\n}\n\nexport class NilPointerException extends Error {\n    constructor() {\n        super('Tried accessing nil pointer field');\n    }\n}\n","import { assertCondition } from '../interpreter/utils/utils';\nimport { OutOfBoundsException } from '../utils/runtimeUtils';\nimport { WORD_SZ } from '../utils/utils';\n\nfunction alignToNextWord(value: number): number {\n    return ((value + WORD_SZ - 1) / WORD_SZ) * WORD_SZ;\n}\n\nexport const MEMORY_PAGES = 256;\nexport const MEMORY_LENGTH = MEMORY_PAGES * 64 * 1024; // 16mb\n\nexport const HEAP_START = alignToNextWord(Math.floor(MEMORY_LENGTH / 3));\nexport const HEAP_END = HEAP_START * 2;\n\nexport const ASYNCIFY_DATA_START = HEAP_END;\nexport const ASYNCIFY_DATA_END = MEMORY_LENGTH;\n\nexport const BYTE_SIZE = 1;\n\nexport class MemoryManager {\n    private allocatedSizes: Map<number, number>;\n    private nextFreeIndex: number;\n\n    constructor(private memory: Uint8Array) {\n        this.nextFreeIndex = HEAP_START;\n        this.allocatedSizes = new Map();\n    }\n\n    alloc = (bytes: number): number => {\n        assertCondition(bytes > 0, 'Cannot alloc 0 bytes');\n        const pointer = this.nextFreeIndex;\n        this.nextFreeIndex += bytes;\n        assertCondition(this.nextFreeIndex < HEAP_END, 'Out of memory!');\n        this.allocatedSizes.set(pointer, bytes);\n        return pointer;\n    };\n\n    checkArrayIndex = (pointer: number, index: number): void => {\n        const byteCount = this.allocatedSizes.get(pointer);\n        if (byteCount === undefined) {\n            throw new Error('Not a valid array');\n        }\n        if (index * WORD_SZ >= byteCount || index < 0) {\n            throw new OutOfBoundsException(index, pointer);\n        }\n\n        return;\n    };\n\n    wordStore = (dir: number, value: number): void => {\n        wordAssertRange(dir);\n\n        this.memory[dir] = value & 255;\n        this.memory[dir + 1] = (value & (255 << 8)) >> 8;\n        this.memory[dir + 2] = (value & (255 << 16)) >> 16;\n        this.memory[dir + 3] = (value & (255 << 24)) >> 24;\n    };\n\n    wordGet = (dir: number): number => {\n        wordAssertRange(dir);\n\n        let value = this.memory[dir];\n        value += this.memory[dir + 1] << 8;\n        value += this.memory[dir + 2] << 16;\n        value += this.memory[dir + 3] << 24;\n\n        return value;\n    };\n\n    byteStore = (dir: number, value: number): void => {\n        byteAssertRange(dir);\n\n        this.memory[dir] = value;\n    };\n\n    byteGet = (dir: number): number => {\n        byteAssertRange(dir);\n\n        return this.memory[dir];\n    };\n\n    wordDebugSlice = (start: number, count: number): void => {\n        const values = [];\n        for (let i = 0; i < count; i++) {\n            const dir = start + i * WORD_SZ;\n            values.push(this.wordGet(dir));\n        }\n\n        console.log(values);\n    };\n\n    byteDebugSlice = (start: number, count: number): void => {\n        const values = [];\n        for (let i = 0; i < count; i++) {\n            const dir = start + i * BYTE_SIZE;\n            values.push(this.byteGet(dir));\n        }\n\n        console.log(values);\n        console.log(values.map((value) => String.fromCharCode(value)));\n    };\n}\n\nconst wordAssertRange = (dir: number): void => {\n    assertCondition(dir >= 0 && dir < HEAP_END - WORD_SZ, `Index ${dir} out of range`);\n};\n\nconst byteAssertRange = (dir: number): void => {\n    assertCondition(dir >= 0 && dir < HEAP_END - BYTE_SIZE, `Index ${dir} out of range`);\n};\n","import { ExpectedValues } from './expectedValues';\n\nexport const WORD_SZ = 4;\n\nexport const noop = () => {};\n\nexport const testExpectedValues = (returnValue: number, expectedValues: ExpectedValues): void => {\n    if (expectedValues.result !== null) {\n        expect(returnValue).toBe(expectedValues.result);\n    }\n};\n\nexport type nil = null | undefined;\nexport const isNil = <T>(value: T | nil): value is nil => {\n    if (value === null || value === undefined) {\n        return true;\n    }\n    return false;\n};\n","import { WORD_SZ } from '../../utils/utils';\nimport { HEAP_START } from '../../evaluator/memoryManager';\nimport { assertCondition } from './utils';\n\nexport class MemMap extends Map<number, number> {\n    private nextFreeMem: number = HEAP_START;\n\n    // Optimistic alloc\n    public alloc = (bytes: number): number => {\n        assertCondition(bytes > 0, 'Cannot alloc 0 words');\n        const nextFree = this.nextFreeMem;\n        this.nextFreeMem += bytes * WORD_SZ;\n        return nextFree;\n    };\n}\n","import { MemMap } from './memMap';\nimport { assertExists } from './utils';\nimport { Label, StringFrag } from '../treeTypes';\n\n/**\n *  StringStorage will handle strings related stuff.\n *\n *  storeString will take a StringFrag (label, string).\n *  It'll store a pointer to that string in memory (pointing\n *  to the index in a private string array) and store that\n *  mem location in the labels map.\n */\nexport class StringStorage {\n    private strings: string[] = [];\n\n    constructor(private memMap: MemMap, private labelMap: Map<Label, number>) {}\n\n    storeString = (stringFrag: StringFrag): number => {\n        const [label, str] = stringFrag.ConstString;\n\n        const addr = this.storeUnlabeledString(str);\n\n        this.labelMap.set(label, addr);\n\n        return addr;\n    };\n\n    storeUnlabeledString = (str: string): number => {\n        const addr = this.memMap.alloc(1);\n        this.strings.push(str);\n        const pointer = this.strings.length - 1;\n\n        this.memMap.set(addr, pointer);\n\n        return addr;\n    };\n\n    loadString = (addr: number): string => {\n        const pointer = assertExists(this.memMap.get(addr));\n        return this.strings[pointer];\n    };\n}\n","import { MemMap } from './utils/memMap';\nimport { assertExists } from './utils/utils';\nimport { StringStorage } from './utils/stringStorage';\nimport { CustomConsole } from '../utils/console';\nimport { WORD_SZ } from '../utils/utils';\nimport { OutOfBoundsException, NilPointerException } from '../utils/runtimeUtils';\nimport { BYTE_SIZE } from '../evaluator/memoryManager';\n\ninterface RuntimeFunctionsByName {\n    print: RuntimeFunction | AsyncRuntimeFunction;\n    flush: RuntimeFunction | AsyncRuntimeFunction;\n    getchar: RuntimeFunction | AsyncRuntimeFunction;\n    getstring: RuntimeFunction | AsyncRuntimeFunction;\n    ord: RuntimeFunction | AsyncRuntimeFunction;\n    chr: RuntimeFunction | AsyncRuntimeFunction;\n    size: RuntimeFunction | AsyncRuntimeFunction;\n    substring: RuntimeFunction | AsyncRuntimeFunction;\n    concat: RuntimeFunction | AsyncRuntimeFunction;\n    not: RuntimeFunction | AsyncRuntimeFunction;\n    debug_words: RuntimeFunction | AsyncRuntimeFunction;\n    debug_bytes: RuntimeFunction | AsyncRuntimeFunction;\n    '+alloc_array': RuntimeFunction | AsyncRuntimeFunction;\n    '+alloc_record': RuntimeFunction | AsyncRuntimeFunction;\n    '+str_equals': RuntimeFunction | AsyncRuntimeFunction;\n    '+str_not_equals': RuntimeFunction | AsyncRuntimeFunction;\n    '+str_less': RuntimeFunction | AsyncRuntimeFunction;\n    '+str_less_or_equals': RuntimeFunction | AsyncRuntimeFunction;\n    '+str_greater': RuntimeFunction | AsyncRuntimeFunction;\n    '+str_greater_or_equals': RuntimeFunction | AsyncRuntimeFunction;\n    '+check_index_array': RuntimeFunction | AsyncRuntimeFunction;\n    '+check_nil': RuntimeFunction | AsyncRuntimeFunction;\n}\n\nexport type RuntimeFunctionNames = keyof RuntimeFunctionsByName;\n\ntype RuntimeFunction = (args: number[]) => number;\ntype AsyncRuntimeFunction = (args: number[]) => Promise<number>;\n\nexport class Runtime {\n    private nameMap: RuntimeFunctionsByName;\n    private arraySizes: Map<number, number>;\n\n    constructor(\n        private memMap: MemMap,\n        private stringStorage: StringStorage,\n        private customConsole: CustomConsole\n    ) {\n        this.arraySizes = new Map();\n        this.nameMap = {\n            print: this.print,\n            flush: this.flush,\n            getchar: this.getchar,\n            getstring: this.getstring,\n            ord: this.ord,\n            chr: this.chr,\n            size: this.size,\n            substring: this.substring,\n            concat: this.concat,\n            not: this.not,\n            debug_words: this.debugWords,\n            debug_bytes: this.debugBytes,\n            '+alloc_array': this.allocArray,\n            '+alloc_record': this.allocRecord,\n            '+str_equals': this.strEquals,\n            '+str_not_equals': this.strNotEquals,\n            '+str_less': this.strLess,\n            '+str_less_or_equals': this.strLessOrEquals,\n            '+str_greater': this.strGreater,\n            '+str_greater_or_equals': this.strGreaterOrEquals,\n            '+check_index_array': this.checkIndexArray,\n            '+check_nil': this.checkNil,\n        };\n    }\n\n    getFunction = (name: RuntimeFunctionNames): RuntimeFunction | AsyncRuntimeFunction => {\n        return this.nameMap[name];\n    };\n\n    maybeGetFunction = (name: string): RuntimeFunction | AsyncRuntimeFunction | undefined => {\n        return this.nameMap[name as RuntimeFunctionNames];\n    };\n\n    /**\n     *  Public functions\n     */\n\n    private print: RuntimeFunction = (args) => {\n        const [strPointer] = args;\n        assertExists(strPointer);\n\n        const str = this.stringStorage.loadString(strPointer);\n        this.customConsole.print(str);\n\n        return 0;\n    };\n\n    private flush: RuntimeFunction = (args) => {\n        return 0;\n    };\n\n    private getchar: AsyncRuntimeFunction = async (args) => {\n        const str = await this.customConsole.readChar();\n        return this.stringStorage.storeUnlabeledString(str[0]);\n    };\n\n    private getstring: AsyncRuntimeFunction = async (args) => {\n        const str = await this.customConsole.read();\n        return this.stringStorage.storeUnlabeledString(str);\n    };\n\n    private ord: RuntimeFunction = (args) => {\n        const [strPointer] = args;\n        assertExists(strPointer);\n\n        const str = this.stringStorage.loadString(strPointer);\n\n        return str.charCodeAt(0);\n    };\n\n    private chr: RuntimeFunction = (args) => {\n        const [charCode] = args;\n        assertExists(charCode);\n\n        const str = String.fromCharCode(charCode);\n        return this.stringStorage.storeUnlabeledString(str);\n    };\n\n    private size: RuntimeFunction = (args) => {\n        const [strPointer] = args;\n        assertExists(strPointer);\n\n        const str = this.stringStorage.loadString(strPointer);\n        return str.length;\n    };\n\n    private substring: RuntimeFunction = (args) => {\n        const [strPointer, start, count] = args;\n        assertExists(strPointer);\n\n        const str = this.stringStorage.loadString(strPointer);\n        const slicedStr = str.slice(start, count);\n\n        return this.stringStorage.storeUnlabeledString(slicedStr);\n    };\n\n    private concat: RuntimeFunction = (args) => {\n        const [leftStrPointer, rightStrPointer] = args;\n        assertExists(leftStrPointer);\n        assertExists(rightStrPointer);\n\n        const leftStr = this.stringStorage.loadString(leftStrPointer);\n        const rightStr = this.stringStorage.loadString(rightStrPointer);\n        const newStr = leftStr + rightStr;\n\n        return this.stringStorage.storeUnlabeledString(newStr);\n    };\n\n    private not: RuntimeFunction = (args) => {\n        const [value] = args;\n        assertExists(value);\n\n        return Number(!value);\n    };\n\n    private debugWords: RuntimeFunction = (args) => {\n        const [pointer, words] = args;\n        assertExists(pointer);\n        assertExists(words);\n\n        for (let i = 0; i < words; i++) {\n            const itemLocation = pointer + i * WORD_SZ;\n\n            console.log(this.memMap.get(itemLocation));\n        }\n\n        return 0;\n    };\n\n    private debugBytes: RuntimeFunction = (args) => {\n        const [pointer, bytes] = args;\n        assertExists(pointer);\n        assertExists(bytes);\n\n        for (let i = 0; i < bytes; i++) {\n            const itemLocation = pointer + i * BYTE_SIZE;\n\n            console.log(this.memMap.get(itemLocation));\n        }\n\n        return 0;\n    };\n\n    /**\n     *  Internal functions\n     */\n\n    private allocArray: RuntimeFunction = (args) => {\n        const [size, init] = args;\n        assertExists(size);\n        assertExists(init);\n\n        const arrayLocation = this.memMap.alloc(size * WORD_SZ);\n        this.arraySizes.set(arrayLocation, size);\n\n        for (let i = 0; i < size; i++) {\n            const itemLocation = arrayLocation + i * WORD_SZ;\n\n            this.memMap.set(itemLocation, init);\n        }\n\n        return arrayLocation;\n    };\n\n    private checkIndexArray: RuntimeFunction = (args) => {\n        const [pointer, index] = args;\n        assertExists(pointer);\n        assertExists(index);\n\n        const size = this.arraySizes.get(pointer);\n\n        if (index < 0 || index >= assertExists(size)) {\n            throw new OutOfBoundsException(index, pointer);\n        }\n\n        return 0;\n    };\n\n    private checkNil: RuntimeFunction = (args) => {\n        const [record] = args;\n        assertExists(record);\n\n        if (record === 0) {\n            throw new NilPointerException();\n        }\n\n        return 0;\n    };\n\n    private allocRecord: RuntimeFunction = (args) => {\n        const [size] = args;\n        assertExists(size);\n\n        const recordLocation = this.memMap.alloc(size * WORD_SZ);\n\n        return recordLocation;\n    };\n\n    private strEquals: RuntimeFunction = (args) => {\n        const comparison = this.strCompare(args);\n        return Number(comparison === 0);\n    };\n\n    private strNotEquals: RuntimeFunction = (args) => {\n        const comparison = this.strCompare(args);\n        return Number(comparison !== 0);\n    };\n\n    private strLess: RuntimeFunction = (args) => {\n        const comparison = this.strCompare(args);\n        return Number(comparison < 0);\n    };\n\n    private strLessOrEquals: RuntimeFunction = (args) => {\n        const comparison = this.strCompare(args);\n        return Number(comparison <= 0);\n    };\n\n    private strGreater: RuntimeFunction = (args) => {\n        const comparison = this.strCompare(args);\n        return Number(comparison > 0);\n    };\n\n    private strGreaterOrEquals: RuntimeFunction = (args) => {\n        const comparison = this.strCompare(args);\n        return Number(comparison >= 0);\n    };\n\n    // extracts the strings and returns their localCompare\n    private strCompare: RuntimeFunction = (args) => {\n        const [leftStrPointer, rightStrPointer] = args;\n\n        const leftStr = this.stringStorage.loadString(assertExists(leftStrPointer));\n        const rightStr = this.stringStorage.loadString(assertExists(rightStrPointer));\n\n        return leftStr.localeCompare(rightStr);\n    };\n}\n","import { Exp, Frag, FunFrag, Stm, Label, GlobalTemp, LocalTemp } from './treeTypes';\nimport { assertExists, UnreachableError, IncludeMap } from './utils/utils';\nimport { accessExpsFromFormals } from './frame';\nimport { findLabelIndex, evalBinop, flatStms } from './utils/treeUtils';\nimport { isFunFrag, isStringFrag } from './utils/fragPatterns';\nimport {\n    isMemExp,\n    isConstExp,\n    isNameExp,\n    isBinopExp,\n    isCallExp,\n    isEseqExp,\n    isLocalExp,\n    isGlobalExp,\n} from './utils/expPatterns';\nimport {\n    isExpStm,\n    isMoveStm,\n    isJumpStm,\n    isCjumpStm,\n    isSeqStm,\n    isLabelStm,\n} from './utils/stmPatterns';\nimport { MemMap } from './utils/memMap';\nimport { StringStorage } from './utils/stringStorage';\nimport { CustomConsole } from '../utils/console';\nimport { Runtime } from './runtime';\n\nconst FRAME_POINTER_OFFSET = 1024 * 1024;\n\nexport class TreeInterpreter {\n    // Map Locals to values, this keeps track of the *current* locals map (per function)\n    private locals: Map<LocalTemp, number>;\n\n    // Map Temps to values\n    private globals: Map<GlobalTemp, number>;\n\n    // Map Labels to mem locations\n    private labels: Map<Label, number>;\n\n    // Map memory location to values\n    private mem: MemMap;\n\n    // String storage\n    private stringStorage: StringStorage;\n\n    // Fragments corresponding to functions.\n    private functions: IncludeMap<FunFrag>;\n\n    // Provides runtime functions\n    private runtime: Runtime;\n\n    constructor(fragments: Frag[], private customConsole: CustomConsole) {\n        this.locals = new Map();\n        this.globals = new Map();\n        this.labels = new Map();\n        this.mem = new MemMap();\n        this.stringStorage = new StringStorage(this.mem, this.labels);\n        this.functions = new IncludeMap();\n\n        fragments.filter(isFunFrag).forEach((frag) => {\n            this.functions.set(frag.Proc.frame.label, frag);\n        });\n\n        fragments.filter(isStringFrag).forEach((frag) => {\n            this.stringStorage.storeString(frag);\n        });\n\n        this.runtime = new Runtime(this.mem, this.stringStorage, this.customConsole);\n    }\n\n    public run = async (): Promise<number> => {\n        // A program starts by calling the function _tigermain\n        const mainLabel = '_tigermain';\n        return await this.evalFunction(mainLabel, [0]);\n    };\n\n    private evalFunction = async (name: string, args: number[]): Promise<number> => {\n        // Find the function and extract it's body and frame.\n        const fragment = assertExists(\n            this.functions.get(name),\n            `Could not find function named '${name}'`\n        );\n        const { body, frame } = fragment.Proc;\n\n        // Store locals for the current function\n        const localsToRestore = this.locals;\n        this.locals = new Map();\n\n        // Move FP very far away from here\n        const prevFp = this.globals.get('fp') ?? 0;\n        this.globals.set('fp', prevFp + FRAME_POINTER_OFFSET);\n\n        // Set up the formals so we can exec the body\n        await this.setupFormals(args, frame.formals);\n\n        // The machine state is ready to run the body, do it.\n        await this.execStms(flatStms(body));\n\n        // Restore locals\n        this.locals = localsToRestore;\n\n        // Retreive the return value, default to 0\n        const rv = this.globals.get('rv') ?? 0;\n\n        this.globals.set('fp', prevFp);\n\n        return rv;\n    };\n\n    /**\n     *  Execute stms in order, there may be internal jumps\n     *  to previous or following stms. This can loop forever!\n     */\n    private execStms = async (stms: Stm[]): Promise<void> => {\n        // Start executing the first stm\n        let executedStmIndex = 0;\n\n        while (executedStmIndex < stms.length) {\n            const stm = stms[executedStmIndex];\n\n            // Evaluate the current stm\n            const maybeLabel: Label | null = await this.evalStm(stm);\n\n            // Find the next stm to evaluate\n            if (maybeLabel === null) {\n                // If no jump continue executing the next stm\n                executedStmIndex++;\n            } else if (maybeLabel === 'done') {\n                // If the label is 'done', the program finished.\n                break;\n            } else {\n                // We've got a label, find the corresponding stm and continue executing from there\n                const nextStmIndex = findLabelIndex(stms, maybeLabel);\n                executedStmIndex = nextStmIndex;\n            }\n        }\n    };\n\n    // Store each value from args in the corresponding temp/mem location\n    private setupFormals = async (args: number[], formals: [string, boolean][]): Promise<void> => {\n        const accessExps = accessExpsFromFormals(formals);\n\n        for (let i = 0; i < args.length; i++) {\n            const arg = args[i];\n            const access = accessExps[i];\n\n            if (isGlobalExp(access)) {\n                // Evaluate the memory location and store the arg there\n                this.globals.set(access.GLOBAL, arg);\n            } else if (isLocalExp(access)) {\n                // Store the argument in the corresponding temp\n                this.locals.set(access.LOCAL, arg);\n            } else {\n                // The access can be either MEM or TEMP.\n                throw new UnreachableError();\n            }\n        }\n    };\n\n    /**\n     *  Evaluate a Stm.\n     *  Return a Label if we need to jump somewhere, null otherwise\n     */\n    private evalStm = async (stm: Stm): Promise<Label | null> => {\n        if (isExpStm(stm)) {\n            await this.evalExp(stm.EXP);\n            return null;\n        }\n\n        if (isMoveStm(stm)) {\n            const [toExp, fromExp] = stm.MOVE;\n            if (isLocalExp(toExp)) {\n                const value: number = await this.evalExp(fromExp);\n\n                this.locals.set(toExp.LOCAL, value);\n                return null;\n            }\n\n            if (isGlobalExp(toExp)) {\n                const value: number = await this.evalExp(fromExp);\n\n                this.globals.set(toExp.GLOBAL, value);\n                return null;\n            }\n\n            if (isMemExp(toExp)) {\n                const location: number = await this.evalExp(toExp.MEM);\n                const value: number = await this.evalExp(fromExp);\n\n                this.mem.set(location, value);\n                return null;\n            }\n\n            throw new UnreachableError(`MOVE to a non Local, Global or Mem expression\\n${toExp}\\n`);\n        }\n\n        if (isJumpStm(stm)) {\n            const [where] = stm.JUMP;\n            if (isNameExp(where)) {\n                return where.NAME;\n            }\n\n            throw new UnreachableError(`JUMP to a non Label expression:\\n${where}\\n`);\n        }\n\n        if (isCjumpStm(stm)) {\n            const [op, leftExp, rightExp, labelTrue, labelFalse] = stm.CJUMP;\n\n            const leftVal = await this.evalExp(leftExp);\n            const rightVal = await this.evalExp(rightExp);\n\n            // 0 means false, everything else means true.\n            const condition = evalBinop(op, leftVal, rightVal);\n            return condition === 0 ? labelFalse : labelTrue;\n        }\n\n        if (isSeqStm(stm)) {\n            throw new UnreachableError('Found SEQ, not a canonical tree!');\n        }\n\n        if (isLabelStm(stm)) {\n            return null;\n        }\n\n        // No more cases\n        throw new UnreachableError();\n    };\n\n    /**\n     *  Evaluate an Exp.\n     *  Every exp evaluates to a number.\n     */\n    private evalExp = async (exp: Exp): Promise<number> => {\n        if (isConstExp(exp)) {\n            return exp.CONST;\n        }\n\n        if (isNameExp(exp)) {\n            return assertExists(\n                this.labels.get(exp.NAME),\n                `Could not find label called '${exp.NAME}'`\n            );\n        }\n\n        if (isLocalExp(exp)) {\n            return assertExists(\n                this.locals.get(exp.LOCAL),\n                `Could not find local called '${exp.LOCAL}'`\n            );\n        }\n\n        if (isGlobalExp(exp)) {\n            return assertExists(\n                this.globals.get(exp.GLOBAL),\n                `Could not find global called '${exp.GLOBAL}'`\n            );\n        }\n\n        if (isBinopExp(exp)) {\n            const [op, leftExp, rightExp] = exp.BINOP;\n\n            const leftVal = await this.evalExp(leftExp);\n            const rightVal = await this.evalExp(rightExp);\n\n            return evalBinop(op, leftVal, rightVal);\n        }\n\n        if (isMemExp(exp)) {\n            const dir = await this.evalExp(exp.MEM);\n            return assertExists(this.mem.get(dir), `Memory location ${dir} is empty!`);\n        }\n\n        if (isCallExp(exp)) {\n            const [labelExp, args] = exp.CALL;\n            if (isNameExp(labelExp)) {\n                const name = labelExp.NAME;\n                const evaluatedArgs = await Promise.all(args.map(this.evalExp));\n\n                let returnValue: number;\n                const runtimeFunction = this.runtime.maybeGetFunction(name);\n                if (runtimeFunction !== undefined) {\n                    returnValue = await runtimeFunction(evaluatedArgs);\n                } else {\n                    returnValue = await this.evalFunction(name, evaluatedArgs);\n                }\n\n                this.globals.set('rv', returnValue);\n\n                return returnValue;\n            } else {\n                throw new UnreachableError('Found CALL to non NAME exp');\n            }\n        }\n\n        if (isEseqExp(exp)) {\n            throw new UnreachableError('Found ESEQ, not a canonical tree!');\n        }\n\n        // No more cases\n        throw new UnreachableError();\n    };\n}\n","import React from 'react';\nimport { CanonResult } from '../Compiler/CompilerInterface';\nimport { CustomConsole } from '../CustomConsole/CustomConsole';\nimport { useConsole } from '../../hooks/useConsole';\nimport { useInterpreter } from '../../hooks/useInterpreter';\n\ninterface InterpreterOkProps {\n    frags: CanonResult;\n}\n\nexport const InterpreterOk: React.FC<InterpreterOkProps> = (props) => {\n    const { frags } = props;\n    const [customConsole, messages, isReading, isReadingChar] = useConsole();\n\n    const [run, isRunning] = useInterpreter(customConsole, frags);\n\n    return (\n        <div className=\"interpreter-container\">\n            <CustomConsole\n                customConsole={customConsole}\n                messages={messages}\n                isReading={isReading}\n                isReadingChar={isReadingChar}\n            />\n            <RunButton disabled={isRunning} onClick={run} />\n        </div>\n    );\n};\n\ninterface RunButtonProps {\n    onClick: () => void;\n    disabled: boolean;\n}\n\nconst RunButton: React.FC<RunButtonProps> = (props) => {\n    return (\n        <button className=\"run-button\" disabled={props.disabled} onClick={props.onClick}>\n            Run interpreter\n        </button>\n    );\n};\n","import { UserConsole } from './useConsole';\nimport { Frag } from '../interpreter/treeTypes';\nimport { TreeInterpreter } from '../interpreter/interpreter';\nimport { useMemo, useState, useCallback } from 'react';\nimport { OutOfBoundsException, NilPointerException } from '../utils/runtimeUtils';\n\nexport type RunFunction = () => Promise<void>;\n\nexport const useInterpreter = (\n    customConsole: UserConsole,\n    frags: Frag[]\n): [RunFunction, boolean] => {\n    const [isRunning, setIsRunning] = useState<boolean>(false);\n\n    const interpreter = useMemo(() => new TreeInterpreter(frags, customConsole), [\n        frags,\n        customConsole,\n    ]);\n\n    const run = useCallback(async () => {\n        customConsole.clear();\n        setIsRunning(true);\n        try {\n            const result = await interpreter.run();\n            customConsole.printLine(`Program ended returning ${result}`);\n        } catch (err) {\n            if (err instanceof OutOfBoundsException) {\n                customConsole.print(\n                    `Program failed!\\nArray index out of bounds.\\nCannot access index ${err.index} from pointer ${err.pointer}`\n                );\n            } else if (err instanceof NilPointerException) {\n                customConsole.print(\n                    `Program failed!\\nNil record exception.\\nCannot access a field of a nil record`\n                );\n            } else {\n                console.error(err);\n                customConsole.print(\n                    `Program failed with message:\\n${err.message}\\n\\nCheck the console for a stack trace`\n                );\n            }\n        }\n        setIsRunning(false);\n    }, [interpreter, customConsole]);\n\n    return [run, isRunning];\n};\n","import React from 'react';\nimport { CanonResult } from '../Compiler/CompilerInterface';\nimport { InterpreterOk } from './InterpreterOk';\n\nimport './Interpreter.scss';\n\ninterface InterpreterProps {\n    canon: CanonResult | null;\n}\nexport const Interpreter: React.FC<InterpreterProps> = (props) => {\n    if (props.canon === null) {\n        return <InterpreterErr />;\n    } else {\n        return <InterpreterOk frags={props.canon} />;\n    }\n};\n\nconst InterpreterErr: React.FC = () => {\n    return (\n        <div className=\"interpreter-container\">\n            <h3>No fragments to show!</h3>\n            <p>Did you compile the code?</p>\n            <p>If so, check the WASM results to see if there were any errors</p>\n        </div>\n    );\n};\n","import { MemoryManager } from './memoryManager';\n\nexport class StringStorage {\n    constructor(private memoryManager: MemoryManager) {}\n\n    readString = (strPointer: number): string => {\n        let string = '';\n        for (let i = 0; true; i++) {\n            const encodedChar = this.memoryManager.byteGet(strPointer + i);\n\n            if (encodedChar === 0) {\n                break;\n            }\n\n            string += String.fromCharCode(encodedChar);\n        }\n\n        return string;\n    };\n\n    writeString = (str: string): number => {\n        const pointer = this.memoryManager.alloc(str.length + 1);\n        for (let i = 0; i < str.length; i++) {\n            const charCode = str.charCodeAt(i);\n            this.memoryManager.byteStore(pointer + i, charCode);\n        }\n        this.memoryManager.byteStore(pointer + str.length, 0);\n\n        return pointer;\n    };\n}\n","const WRAPPED_EXPORTS = new WeakMap();\n\nfunction isPromise(obj) {\n    return (\n        !!obj &&\n        (typeof obj === 'object' || typeof obj === 'function') &&\n        typeof obj.then === 'function'\n    );\n}\n\nfunction proxyGet(obj, transform) {\n    return new Proxy(obj, {\n        get: (obj, name) => transform(obj[name]),\n    });\n}\n\nclass Asyncify {\n    constructor(dataAddr, dataEnd) {\n        this.dataAddr = dataAddr;\n        this.dataEnd = dataEnd;\n        this.dataStart = this.dataAddr + 8;\n        this.state = { type: 'Loading' };\n        this.exports = null;\n    }\n\n    assertNoneState() {\n        if (this.state.type !== 'None') {\n            throw new Error(`Invalid async state ${this.state.type}`);\n        }\n    }\n\n    wrapImportFn(fn) {\n        return (...args) => {\n            if (this.state.type === 'Rewinding') {\n                let { value } = this.state;\n                this.state = { type: 'None' };\n                this.exports.asyncify_stop_rewind();\n                return value;\n            }\n            this.assertNoneState();\n            let value = fn(...args);\n            if (!isPromise(value)) {\n                return value;\n            }\n            this.exports.asyncify_start_unwind(this.dataAddr);\n            this.state = {\n                type: 'Unwinding',\n                promise: value,\n            };\n        };\n    }\n\n    wrapModuleImports(module) {\n        return proxyGet(module, (value) => {\n            if (typeof value === 'function') {\n                return this.wrapImportFn(value);\n            }\n            return value;\n        });\n    }\n\n    wrapImports(imports) {\n        if (imports === undefined) return;\n\n        return proxyGet(imports, (moduleImports) => this.wrapModuleImports(moduleImports));\n    }\n\n    wrapExportFn(fn) {\n        let newExport = WRAPPED_EXPORTS.get(fn);\n\n        if (newExport !== undefined) {\n            return newExport;\n        }\n\n        newExport = async (...args) => {\n            this.assertNoneState();\n\n            let result = fn(...args);\n\n            while (this.state.type === 'Unwinding') {\n                let { promise } = this.state;\n                this.state = { type: 'None' };\n                this.exports.asyncify_stop_unwind();\n                let value = await promise;\n                this.assertNoneState();\n                this.exports.asyncify_start_rewind(this.dataAddr);\n                this.state = {\n                    type: 'Rewinding',\n                    value,\n                };\n                result = fn();\n            }\n\n            this.assertNoneState();\n\n            return result;\n        };\n\n        WRAPPED_EXPORTS.set(fn, newExport);\n\n        return newExport;\n    }\n\n    wrapExports(exports) {\n        let newExports = Object.create(null);\n\n        for (let exportName in exports) {\n            let value = exports[exportName];\n            if (typeof value === 'function' && !exportName.startsWith('asyncify_')) {\n                value = this.wrapExportFn(value);\n            }\n            Object.defineProperty(newExports, exportName, {\n                enumerable: true,\n                value,\n            });\n        }\n\n        WRAPPED_EXPORTS.set(exports, newExports);\n\n        return newExports;\n    }\n\n    init(instance, imports) {\n        const { exports } = instance;\n\n        const memory = exports.memory || (imports.mem && imports.mem.memory);\n\n        new Int32Array(memory.buffer, this.dataAddr).set([this.dataStart, this.dataEnd]);\n\n        this.state = { type: 'None' };\n\n        this.exports = this.wrapExports(exports);\n\n        Object.setPrototypeOf(instance, Instance.prototype);\n    }\n}\n\nexport class Instance extends WebAssembly.Instance {\n    constructor(module, dataAddr, dataEnd, imports) {\n        let state = new Asyncify(dataAddr, dataEnd);\n        super(module, state.wrapImports(imports));\n        state.init(this, imports);\n    }\n\n    get exports() {\n        return WRAPPED_EXPORTS.get(super.exports);\n    }\n}\n\nObject.defineProperty(Instance.prototype, 'exports', { enumerable: true });\n\nexport async function instantiate(source, dataAddr, dataEnd, imports) {\n    let state = new Asyncify(dataAddr, dataEnd);\n    let result = await WebAssembly.instantiate(source, state.wrapImports(imports));\n    state.init(result instanceof WebAssembly.Instance ? result : result.instance, imports);\n    return result;\n}\n","import { CustomConsole } from '../utils/console';\nimport {\n    MemoryManager,\n    MEMORY_PAGES,\n    ASYNCIFY_DATA_START,\n    ASYNCIFY_DATA_END,\n} from './memoryManager';\nimport { StringStorage } from './stringStorage';\nimport { RuntimeExit, NilPointerException } from '../utils/runtimeUtils';\nimport * as Asyncify from './asyncify';\nimport { WORD_SZ } from '../utils/utils';\n\ntype TigerMain = () => Promise<number>;\n\nexport class Runtime {\n    private memoryManager: MemoryManager;\n    private stringStorage: StringStorage;\n    private instanceImports: Record<string, Record<string, WebAssembly.ImportValue>>;\n\n    constructor(private binary: Uint8Array, private customConsole: CustomConsole) {\n        const memory = new WebAssembly.Memory({ initial: MEMORY_PAGES, maximum: MEMORY_PAGES });\n\n        this.memoryManager = new MemoryManager(new Uint8Array(memory.buffer));\n        this.stringStorage = new StringStorage(this.memoryManager);\n        this.instanceImports = {\n            mem: {\n                memory,\n            },\n            externals: {\n                print: this.print,\n                flush: this.flush,\n                getchar: this.getchar,\n                getstring: this.getstring,\n                ord: this.ord,\n                chr: this.chr,\n                size: this.size,\n                substring: this.substring,\n                concat: this.concat,\n                not: this.not,\n                exit: this.exit,\n                alloc_array: this.alloc_array,\n                alloc_record: this.alloc_record,\n                debug_words: this.debug_words,\n                debug_bytes: this.debug_bytes,\n                check_index_array: this.check_index_array,\n                check_nil: this.check_nil,\n                str_equals: this.str_equals,\n                str_not_equals: this.str_not_equals,\n                str_less: this.str_less,\n                str_less_or_equals: this.str_less_or_equals,\n                str_greater: this.str_greater,\n                str_greater_or_equals: this.str_greater_or_equals,\n            },\n        };\n    }\n\n    run = async (): Promise<number> => {\n        try {\n            const wasmInstance = await Asyncify.instantiate(\n                this.binary,\n                ASYNCIFY_DATA_START,\n                ASYNCIFY_DATA_END,\n                this.instanceImports\n            );\n\n            const main = wasmInstance.instance.exports.tigermain_wrapper as TigerMain;\n            const execution = await main();\n\n            return execution;\n        } catch (err) {\n            if (err instanceof RuntimeExit) {\n                return err.exitCode;\n            } else {\n                throw err;\n            }\n        }\n    };\n\n    private print = (strPointer: number): number => {\n        const string = this.stringStorage.readString(strPointer);\n        this.customConsole.print(string);\n        return 0;\n    };\n    private flush = (): number => {\n        return 0;\n    };\n    private getchar = async (): Promise<number> => {\n        const string = await this.customConsole.readChar();\n        return this.stringStorage.writeString(string);\n    };\n    private getstring = async (): Promise<number> => {\n        const string = await this.customConsole.read();\n        return this.stringStorage.writeString(string);\n    };\n    private ord = (strPointer: number): number => {\n        const string = this.stringStorage.readString(strPointer);\n        return string.charCodeAt(0);\n    };\n    private chr = (charCode: number): number => {\n        const string = String.fromCharCode(charCode);\n        return this.stringStorage.writeString(string);\n    };\n    private size = (strPointer: number): number => {\n        const string = this.stringStorage.readString(strPointer);\n        return string.length;\n    };\n    private substring = (strPointer: number, start: number, end: number): number => {\n        const string = this.stringStorage.readString(strPointer);\n        const slicedString = string.slice(start, end);\n        const newStrPointer = this.stringStorage.writeString(slicedString);\n        return newStrPointer;\n    };\n    private concat = (str1Pointer: number, str2Pointer: number): number => {\n        const str1 = this.stringStorage.readString(str1Pointer);\n        const str2 = this.stringStorage.readString(str2Pointer);\n\n        return this.stringStorage.writeString(str1 + str2);\n    };\n    private not = (condition: number): number => {\n        return Number(!condition);\n    };\n    private exit = (exitCode: number) => {\n        throw new RuntimeExit(exitCode);\n    };\n    private alloc_array = (size: number, init: number): number => {\n        const pointer = this.memoryManager.alloc(size * WORD_SZ);\n        for (let i = 0; i < size; i++) {\n            const dir = pointer + i * WORD_SZ;\n            this.memoryManager.wordStore(dir, init);\n        }\n\n        return pointer;\n    };\n    private alloc_record = (size: number): number => {\n        const pointer = this.memoryManager.alloc(size * WORD_SZ);\n        console.log(`Alloc'd record in ${pointer}`);\n        return pointer;\n    };\n    private debug_words = (pointer: number, words: number) => {\n        console.log(`Will print ${words} words from pointer ${pointer}`);\n        this.memoryManager.wordDebugSlice(pointer, words);\n        return 0;\n    };\n    private debug_bytes = (pointer: number, bytes: number) => {\n        console.log(`Will print ${bytes} bytes from pointer ${pointer}`);\n        this.memoryManager.byteDebugSlice(pointer, bytes);\n        return 0;\n    };\n    private check_index_array = (pointer: number, index: number): number => {\n        this.memoryManager.checkArrayIndex(pointer, index);\n        return 0;\n    };\n    private check_nil = (record: number): number => {\n        if (record === 0) {\n            throw new NilPointerException();\n        }\n        return 0;\n    };\n    private str_equals = (leftStrPointer: number, rightStrPointer: number): number => {\n        const comparison = this.strCompare(leftStrPointer, rightStrPointer);\n\n        return Number(comparison === 0);\n    };\n    private str_not_equals = (leftStrPointer: number, rightStrPointer: number): number => {\n        const comparison = this.strCompare(leftStrPointer, rightStrPointer);\n\n        return Number(comparison !== 0);\n    };\n    private str_less = (leftStrPointer: number, rightStrPointer: number): number => {\n        const comparison = this.strCompare(leftStrPointer, rightStrPointer);\n\n        return Number(comparison < 0);\n    };\n    private str_less_or_equals = (leftStrPointer: number, rightStrPointer: number): number => {\n        const comparison = this.strCompare(leftStrPointer, rightStrPointer);\n\n        return Number(comparison <= 0);\n    };\n    private str_greater = (leftStrPointer: number, rightStrPointer: number): number => {\n        const comparison = this.strCompare(leftStrPointer, rightStrPointer);\n\n        return Number(comparison > 0);\n    };\n    private str_greater_or_equals = (leftStrPointer: number, rightStrPointer: number): number => {\n        const comparison = this.strCompare(leftStrPointer, rightStrPointer);\n\n        return Number(comparison >= 0);\n    };\n\n    private strCompare = (leftStrPointer: number, rightStrPointer: number): number => {\n        const leftStr = this.stringStorage.readString(leftStrPointer);\n        const rightStr = this.stringStorage.readString(rightStrPointer);\n\n        return leftStr.localeCompare(rightStr);\n    };\n}\n","import { CustomConsole } from '../utils/console';\nimport binaryen from 'binaryen';\nimport { Runtime } from './runtime';\n\nexport interface Evaluator {\n    run(): Promise<number>;\n}\n\nexport class WasmEvaluator implements Evaluator {\n    private runtime: Runtime;\n\n    constructor(binaryWasm: Uint8Array, customConsole: CustomConsole) {\n        const wasmModule = binaryen.readBinary(binaryWasm);\n        binaryen.setOptimizeLevel(1);\n        wasmModule.runPasses(['asyncify']);\n        const binary = wasmModule.emitBinary();\n\n        this.runtime = new Runtime(binary, customConsole);\n    }\n\n    run = async () => {\n        return this.runtime.run();\n    };\n}\n","import React from 'react';\nimport { CustomConsole } from '../CustomConsole/CustomConsole';\nimport { useConsole } from '../../hooks/useConsole';\nimport { useEvaluator } from '../../hooks/useEvaluator';\n\ninterface EvaluatorOkProps {\n    bin: any;\n}\n\nexport const EvaluatorOk: React.FC<EvaluatorOkProps> = (props) => {\n    const { bin } = props;\n    const [customConsole, messages, isReading, isReadingChar] = useConsole();\n\n    const [run, isRunning] = useEvaluator(customConsole, bin);\n\n    return (\n        <div className=\"evaluator-container\">\n            <CustomConsole\n                customConsole={customConsole}\n                messages={messages}\n                isReading={isReading}\n                isReadingChar={isReadingChar}\n            />\n            <RunButton disabled={isRunning} onClick={run} />\n        </div>\n    );\n};\n\ninterface RunButtonProps {\n    onClick: () => void;\n    disabled: boolean;\n}\n\nconst RunButton: React.FC<RunButtonProps> = (props) => {\n    return (\n        <button className=\"run-button\" disabled={props.disabled} onClick={props.onClick}>\n            Run program\n        </button>\n    );\n};\n","import { UserConsole } from './useConsole';\nimport { useMemo, useState, useCallback } from 'react';\nimport { WasmEvaluator } from '../evaluator/evaluator';\nimport { OutOfBoundsException, NilPointerException } from '../utils/runtimeUtils';\n\nexport type RunFunction = () => Promise<void>;\n\nexport const useEvaluator = (customConsole: UserConsole, bin: any): [RunFunction, boolean] => {\n    const [isRunning, setIsRunning] = useState<boolean>(false);\n\n    const evaluator = useMemo(() => new WasmEvaluator(Uint8Array.from(bin), customConsole), [\n        bin,\n        customConsole,\n    ]);\n\n    const run = useCallback(async () => {\n        customConsole.clear();\n        setIsRunning(true);\n        try {\n            const result = await evaluator.run();\n            customConsole.printLine(`Program ended returning ${result}`);\n        } catch (err) {\n            if (err instanceof OutOfBoundsException) {\n                customConsole.print(\n                    `Program failed!\\nArray index out of bounds.\\nCannot access index ${err.index} from pointer ${err.pointer}`\n                );\n            } else if (err instanceof NilPointerException) {\n                customConsole.print(\n                    `Program failed!\\nNil record exception.\\nCannot access a field of a nil record`\n                );\n            } else {\n                console.error(err);\n                customConsole.printLine(\n                    `Program failed with message:\\n${err.message}\\n\\nCheck the console for a stack trace`\n                );\n            }\n        }\n        setIsRunning(false);\n    }, [evaluator, customConsole]);\n\n    return [run, isRunning];\n};\n","import React, { ErrorInfo } from 'react';\n\ninterface ErrorBoundaryProps {\n    fallback: React.ReactNode;\n    children: React.ReactNode;\n}\n\ninterface ErrorBoundaryState {\n    error: Error | null;\n}\n\nexport class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {\n    readonly state = {\n        error: null,\n    };\n\n    static getDerivedStateFromError(error: Error) {\n        return { error };\n    }\n\n    componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n        console.error(error, errorInfo);\n    }\n\n    render(): JSX.Element {\n        if (this.state.error !== null) {\n            return <>{this.props.fallback}</>;\n        }\n\n        return <>{this.props.children}</>;\n    }\n}\n","import React from 'react';\nimport { EvaluatorOk } from './EvaluatorOk';\nimport { ErrorBoundary } from './ErrorBoundary';\nimport './Evaluator.scss';\n\ninterface EvaluatorProps {\n    bin: any;\n}\n\nexport const Evaluator: React.FC<EvaluatorProps> = (props) => {\n    if (props.bin === null) {\n        return <EvaluatorError />;\n    } else {\n        return (\n            <ErrorBoundary fallback={<EvaluatorError />}>\n                <EvaluatorOk bin={props.bin} />\n            </ErrorBoundary>\n        );\n    }\n};\n\nconst EvaluatorError: React.FC = () => {\n    return (\n        <div className=\"evaluator-container\">\n            <h3>Something went wrong compiling the code!</h3>\n            <p>Check the console for further info</p>\n        </div>\n    );\n};\n","import React from 'react';\n\nexport interface TabProps {\n    name: string;\n    children: React.ReactNode;\n}\n\nexport const Tab: React.FC<TabProps> = (props) => {\n    return <>{props.children}</>;\n};\n","import React, { useState, useCallback } from 'react';\nimport { TabProps } from './Tab';\nimport { isNil } from '../../utils/utils';\nimport { useCtrlAltKeys } from '../../hooks/useCtrlAltKeys';\nimport './Tabs.scss';\n\ninterface TabsProps {\n    children: React.ReactNode;\n}\n\n// Should only receive Tab components\nexport const Tabs: React.FC<TabsProps> = (props) => {\n    const [selectedIndex, setSelectedIndex] = useState(0);\n\n    const names = React.Children.map(props.children, (child) => {\n        if (!child) {\n            throw new Error('Tabs component must have Tab children');\n        }\n\n        const anyChild = child as any;\n        if (!anyChild.props) {\n            throw new Error('Tabs component must have Tab children');\n        }\n\n        const props = anyChild.props as TabProps;\n        if (!props.name) {\n            throw new Error('Tabs component must have Tab children');\n        }\n\n        return props.name;\n    });\n\n    if (isNil(names)) {\n        throw new Error('Tabs component must have Tab children');\n    }\n\n    const tabsArray = React.Children.toArray(props.children);\n    const visibleTab = tabsArray[selectedIndex];\n\n    return (\n        <div className=\"tabs-container\">\n            <TabsButtons\n                names={names}\n                selectedIndex={selectedIndex}\n                setSelectedIndex={setSelectedIndex}\n            />\n            {visibleTab}\n        </div>\n    );\n};\n\ninterface TabsButtonsProps {\n    names: string[];\n    selectedIndex: number;\n    setSelectedIndex: React.Dispatch<React.SetStateAction<number>>;\n}\nconst TabsButtons: React.FC<TabsButtonsProps> = ({ names, selectedIndex, setSelectedIndex }) => {\n    return (\n        <div className=\"tabs-buttons\">\n            {names.map((name, index) => (\n                <TabButton\n                    key={name}\n                    name={name}\n                    index={index}\n                    selectedIndex={selectedIndex}\n                    setSelectedIndex={setSelectedIndex}\n                />\n            ))}\n        </div>\n    );\n};\n\ninterface TabButtonProps {\n    name: string;\n    index: number;\n    selectedIndex: number;\n    setSelectedIndex: React.Dispatch<React.SetStateAction<number>>;\n}\n\nconst TabButton: React.FC<TabButtonProps> = ({ name, index, selectedIndex, setSelectedIndex }) => {\n    const selectedClass = index === selectedIndex ? 'selected' : '';\n\n    const moveToTab = useCallback(() => {\n        setSelectedIndex(index);\n    }, [index, setSelectedIndex]);\n    useCtrlAltKeys([49 + index], moveToTab);\n\n    return (\n        <button key={name} className={selectedClass} onClick={moveToTab}>\n            {name}\n        </button>\n    );\n};\n","import { useEffect } from 'react';\n\nexport const useCtrlAltKeys = (compileKeyCodes: number[], handler: () => void): void => {\n    useEffect(() => {\n        const keyHandler = (e: KeyboardEvent): void => {\n            if (compileKeyCodes.includes(e.keyCode) && e.ctrlKey && e.altKey) {\n                handler();\n                e.preventDefault();\n            }\n        };\n\n        document.addEventListener('keydown', keyHandler);\n\n        return () => {\n            document.removeEventListener('keydown', keyHandler);\n        };\n    }, [handler, compileKeyCodes]);\n};\n","import React from 'react';\nimport { useWatFromWasm } from '../../hooks/useWatFromWasm';\nimport './WASMViewer.scss';\n\ninterface WASMViewerProps {\n    bin: any;\n}\n\nexport const WASMViewer: React.FC<WASMViewerProps> = ({ bin }) => {\n    const wat = useWatFromWasm(bin);\n    return (\n        <div className=\"wat-container\">\n            <pre>{wat}</pre>\n        </div>\n    );\n};\n","import binaryen from 'binaryen';\nimport { useMemo } from 'react';\n\nexport const useWatFromWasm = (bin: any): string => {\n    const memoizedText = useMemo(() => {\n        const wasmModule = binaryen.readBinary(bin);\n        return wasmModule.emitText();\n    }, [bin]);\n\n    return memoizedText;\n};\n","import { CompileResult, CompileFunction } from '../components/Compiler/CompilerInterface';\nimport { useState } from 'react';\nimport { baseCode } from '../utils/baseCode';\nimport { useLocalStorageState } from './useLocalStorageState';\n\nexport type CompileCodeAction = (source: string) => void;\n\nexport const useCompileResult = (\n    compile: CompileFunction\n): [string, React.Dispatch<React.SetStateAction<string>>, CompileResult, CompileCodeAction] => {\n    const [code, setCode] = useLocalStorageState<string>('hector-code', baseCode);\n\n    const [compileResult, setCompileResult] = useState<CompileResult>({\n        parse: null,\n        typecheck: null,\n        escape: null,\n        translate: null,\n        canon: null,\n        wasm: null,\n        bin: null,\n    });\n\n    const [lastCompiledCode, setLastCompiledCode] = useState<string>('');\n\n    const compileCode = (source: string): void => {\n        try {\n            if (source !== '' && source !== lastCompiledCode) {\n                const result = compile(source);\n                console.log(result);\n                setCompileResult(result);\n                setLastCompiledCode(source);\n            }\n        } catch (err) {\n            console.log('Something went wrong compiling your code!');\n            console.error(err);\n            setCompileResult({\n                parse: null,\n                typecheck: null,\n                escape: null,\n                translate: null,\n                canon: null,\n                wasm: null,\n                bin: null,\n            });\n        }\n    };\n\n    return [code, setCode, compileResult, compileCode];\n};\n","import { useState, useCallback } from 'react';\n\nexport const useLocalStorageState = <T>(\n    key: string,\n    initialValue: T\n): [T, React.Dispatch<React.SetStateAction<T>>] => {\n    // Pass initial state function to useState so logic is only executed once\n    const [storedValue, setStoredValue] = useState<T>(() => {\n        try {\n            const item: string | null = window.localStorage.getItem(key);\n            // Parse stored json or if none return initialValue\n            return item ? JSON.parse(item) : initialValue;\n        } catch (error) {\n            // If error also return initialValue\n            console.log(error);\n            return initialValue;\n        }\n    });\n\n    // Return a wrapped version of useState's setter function that persists the new value to localStorage.\n    const setValue: React.Dispatch<React.SetStateAction<T>> = useCallback(\n        (value): void => {\n            try {\n                // Allow value to be a function so we have same API as useState\n                const valueToStore: T = value instanceof Function ? value(storedValue) : value;\n\n                setStoredValue(valueToStore);\n\n                window.localStorage.setItem(key, JSON.stringify(valueToStore));\n            } catch (error) {\n                // We'll suppose you have localstorage, if not well... Just log for now.\n                console.warn(error);\n            }\n        },\n        [key, storedValue]\n    );\n\n    return [storedValue, setValue];\n};\n","export const baseCode = `\n/* Enter your tiger code */\n(\n    print(\"Hello world!\");\n    0\n)\n`;\n","import React from 'react';\nimport { CodeEditor } from '../CodeEditor/CodeEditor';\nimport { ASTViewer } from '../ASTViewer/ASTViewer';\nimport { TREEViewer } from '../TREEViewer/TREEViewer';\nimport { CanonViewer } from '../CanonViewer/CanonViewer';\nimport { Interpreter } from '../Interpreter/Interpreter';\nimport { Frag } from '../../interpreter/treeTypes';\nimport { Evaluator } from '../Evaluator/Evaluator';\nimport { Tab } from '../Tabs/Tab';\nimport { Tabs } from '../Tabs/Tabs';\nimport { WASMViewer } from '../WASMViewer/WASMViewer';\nimport { useCompileResult } from '../../hooks/useCompileResult';\n\n// Bad type. You can get either Ok or Err. Improve this.\nexport type RustOption<T> = {\n    Ok?: T;\n    Err?: any;\n};\n\nexport type ParseResult = RustOption<any> | null;\nexport type TypecheckResult = RustOption<any> | null;\nexport type EscapeResult = any;\nexport type TranslateResult = RustOption<any> | null;\nexport type CanonResult = Frag[];\nexport type WasmResult = any; // Not implemented\n\nexport interface CompileResult {\n    parse: ParseResult;\n    typecheck: ParseResult;\n    escape: any;\n    translate: ParseResult;\n    canon: CanonResult | null;\n    wasm: string | null;\n    bin: any;\n}\n\nexport type CompileFunction = (source: string) => CompileResult;\n\ninterface CompilerProps {\n    compile: CompileFunction;\n}\n\nexport const CompilerInterface: React.FC<CompilerProps> = ({ compile }) => {\n    const [code, setCode, compileResult, compileCode] = useCompileResult(compile);\n\n    return (\n        <div className=\"compiler-interface\">\n            <Tabs>\n                <Tab name=\"Editor\">\n                    <CodeEditor code={code} setCode={setCode} compileCode={compileCode} />\n                </Tab>\n                <Tab name=\"AST\">\n                    <ASTViewer ast={compileResult.escape} />\n                </Tab>\n                <Tab name=\"TREE\">\n                    <TREEViewer fragments={compileResult.translate} />\n                </Tab>\n                <Tab name=\"Canon\">\n                    <CanonViewer canon={compileResult.canon} />\n                </Tab>\n                <Tab name=\"WASM\">\n                    <WASMViewer bin={compileResult.bin} />\n                </Tab>\n                <Tab name=\"Interpreter\">\n                    <Interpreter canon={compileResult.canon} />\n                </Tab>\n                <Tab name=\"Evaluator\">\n                    <Evaluator bin={compileResult.bin} />\n                </Tab>\n            </Tabs>\n            <p className=\"compile-instructions\">\n                Psst! compile the code with <strong>Ctrl + enter</strong> or{' '}\n                <strong>Ctrl + s</strong>\n            </p>\n        </div>\n    );\n};\n","import React, { Suspense } from 'react';\nimport { CompilerInterface } from './CompilerInterface';\n\nimport './Compiler.scss';\n\nconst AsyncCompiler = React.lazy(\n    async (): Promise<any> => {\n        const wasm = await import('hector');\n        const Component: React.FC = () => <CompilerInterface compile={wasm.compile} />;\n\n        return { default: Component };\n    }\n);\n\nexport const Compiler: React.FC = () => {\n    return (\n        <div className=\"compiler-container\">\n            <Suspense fallback={<div>Loading...</div>}>\n                <AsyncCompiler />\n            </Suspense>\n        </div>\n    );\n};\n","import React from 'react';\nimport './Header.scss';\n\nexport const Header: React.FC = () => {\n    return (\n        <header className=\"header-container\">\n            <h1 className=\"title\">HECTOR</h1>\n            <span className=\"description\">Heuristically Excessive Compiler for Tiger On Rust</span>\n        </header>\n    );\n};\n","import React from 'react';\nimport './Footer.scss';\n\nexport const Footer: React.FC = () => {\n    return (\n        <footer className=\"footer-container\">\n            Made with <Rage /> and <Blood /> by <IvoLink /> and <FedeLink />\n        </footer>\n    );\n};\n\nconst Blood: React.FC = () => {\n    return (\n        <span role=\"img\" aria-label=\"blood\" className=\"blood emoji\">\n            🩸\n        </span>\n    );\n};\n\nconst Rage: React.FC = () => {\n    return (\n        <span role=\"img\" aria-label=\"rage\" className=\"rage emoji\">\n            😡\n        </span>\n    );\n};\n\nconst IvoLink: React.FC = () => {\n    return (\n        <a\n            className=\"link\"\n            href=\"https://github.com/ivoelbert\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n        >\n            Ivo Elbert\n        </a>\n    );\n};\n\nconst FedeLink: React.FC = () => {\n    return (\n        <a\n            className=\"link\"\n            href=\"https://github.com/QPotato\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n        >\n            Fede Badaloni\n        </a>\n    );\n};\n","import React from 'react';\nimport { Compiler } from './components/Compiler/Compiler';\nimport { Header } from './components/Header/Header';\nimport { Footer } from './components/Footer.tsx/Footer';\n\nconst App: React.FC = () => {\n    return (\n        <div className=\"app\">\n            <div>\n                <Header />\n                <Compiler />\n            </div>\n            <Footer />\n        </div>\n    );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport './index.scss';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}