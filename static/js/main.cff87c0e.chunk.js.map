{"version":3,"sources":["hooks/useLocalStorageState.ts","utils/baseCode.ts","components/CodeEditor/useExamples.tsx","components/CodeEditor/examples/factorial.tig","components/CodeEditor/examples/stringConcat.tig","components/CodeEditor/examples/basicArray.tig","components/CodeEditor/examples/fizzbuzz.tig","components/CodeEditor/examples/bubbleSort.tig","components/CodeEditor/examples/queens.tig","components/CodeEditor/Examples.tsx","components/CodeEditor/CodeEditor.tsx","hooks/useCtrlKeys.ts","components/ASTViewer/ASTViewer.tsx","utils/cleanAst.ts","components/TREEViewer/TREEViewer.tsx","components/CanonViewer/CanonViewer.tsx","components/CustomConsole/CustomConsole.tsx","hooks/useConsole.ts","interpreter/utils/utils.ts","interpreter/frame.ts","interpreter/utils/stmPatterns.ts","interpreter/utils/treeUtils.ts","interpreter/utils/fragPatterns.ts","interpreter/utils/expPatterns.ts","utils/runtimeUtils.ts","evaluator/memoryManager.ts","utils/utils.ts","interpreter/utils/memMap.ts","interpreter/utils/stringStorage.ts","interpreter/runtime.ts","interpreter/interpreter.ts","components/Interpreter/InterpreterOk.tsx","hooks/useInterpreter.ts","components/Interpreter/Interpreter.tsx","evaluator/stringStorage.ts","evaluator/asyncify.js","evaluator/runtime.ts","evaluator/evaluator.ts","components/Evaluator/EvaluatorOk.tsx","hooks/useEvaluator.ts","components/Evaluator/ErrorBoundary.tsx","components/Evaluator/Evaluator.tsx","components/Tabs/Tab.tsx","components/Tabs/Tabs.tsx","hooks/useCtrlAltKeys.ts","components/WASMViewer/WASMViewer.tsx","hooks/useWatFromWasm.ts","components/Compiler/CompilerInterface.tsx","hooks/useCompileResult.ts","components/Compiler/Compiler.tsx","components/Header/Header.tsx","App.tsx","index.tsx"],"names":["useLocalStorageState","key","initialValue","useState","item","window","localStorage","getItem","JSON","parse","error","console","log","storedValue","setStoredValue","setValue","useCallback","value","valueToStore","Function","setItem","stringify","warn","baseCode","EXAMPLES","Examples","setCode","examples","setExamples","name","code","newExamples","useExamples","className","Object","entries","map","fileName","content","ExampleItem","onClick","CodeEditor","props","compileKeyCodes","handler","compileCode","useEffect","keyHandler","e","includes","keyCode","ctrlKey","preventDefault","document","addEventListener","removeEventListener","mode","theme","onChange","newCode","editorProps","$blockScrolling","style","height","fontSize","width","showPrintMargin","onLoad","editor","focus","onBlur","ASTViewer","ast","OkASTViewer","cleanType","cleanPosition","cleanNode","cleanEscape","options","setOptions","prettyAst","useMemo","cleanAst","Array","isArray","keys","forEach","k","nodeName","elem","isValidAst","length","src","enableClipboard","displayObjectSize","displayDataTypes","CleanControls","collapsed","setCollapsed","optionsClassName","option","id","type","checked","htmlFor","TREEViewer","fragments","undefined","Err","OkTREEViewer","CanonViewer","canon","OkCanonViewer","CustomConsole","messages","isReading","isReadingChar","customConsole","consoleRef","useRef","element","current","scrollTop","scrollHeight","ref","msg","index","MessageWithPrompt","message","children","ConsoleInput","setMessage","autoFocus","event","target","onKeyPress","resolveRead","spellCheck","ConsoleCharInput","illegalResolve","str","Error","useConsole","setMessages","setIsReading","setIsReadingChar","clear","_oldMessages","print","oldMessages","newMessages","concat","replace","printLine","read","Promise","resolve","readChar","char","UnexpectedUndefinedError","UnreachableError","assertExists","assertCondition","condition","IncludeMap","set","foundIndex","findIndex","entry","push","get","maybeEntry","find","this","accessExpFromFormal","formal","LOCAL","inLocalAccessExp","accessExpsFromFormals","formals","isExpStm","stm","isMoveStm","isJumpStm","isCjumpStm","isSeqStm","isLabelStm","findLabelIndex","stms","label","LABEL","flatStms","fragStms","fragStm","evalBinop","op","leftVal","rightVal","Math","floor","Number","isFunFrag","fragment","isStringFrag","isConstExp","exp","isNameExp","isLocalExp","isGlobalExp","isBinopExp","isMemExp","isCallExp","isEseqExp","RuntimeExit","exitCode","OutOfBoundsException","pointer","NilPointerException","HEAP_START","MEMORY_PAGES","HEAP_END","ASYNCIFY_DATA_START","MemoryManager","memory","allocatedSizes","nextFreeIndex","alloc","bytes","checkArrayIndex","byteCount","wordStore","dir","wordAssertRange","wordGet","byteStore","byteAssertRange","byteGet","wordDebugSlice","start","count","values","i","byteDebugSlice","String","fromCharCode","Map","MemMap","nextFreeMem","nextFree","StringStorage","memMap","labelMap","strings","storeString","stringFrag","ConstString","addr","storeUnlabeledString","loadString","Runtime","stringStorage","nameMap","arraySizes","getFunction","maybeGetFunction","args","strPointer","flush","getchar","a","getstring","ord","charCodeAt","chr","charCode","size","substring","slicedStr","slice","leftStrPointer","rightStrPointer","newStr","not","debugWords","words","itemLocation","debugBytes","allocArray","init","arrayLocation","checkIndexArray","checkNil","record","allocRecord","strEquals","comparison","strCompare","strNotEquals","strLess","strLessOrEquals","strGreater","strGreaterOrEquals","leftStr","rightStr","localeCompare","debug_words","debug_bytes","TreeInterpreter","locals","globals","labels","mem","functions","runtime","run","evalFunction","Proc","body","frame","localsToRestore","prevFp","setupFormals","execStms","rv","executedStmIndex","evalStm","maybeLabel","nextStmIndex","accessExps","arg","access","GLOBAL","evalExp","EXP","MOVE","toExp","fromExp","MEM","location","JUMP","where","NAME","CJUMP","leftExp","rightExp","labelTrue","labelFalse","CONST","BINOP","CALL","labelExp","all","evaluatedArgs","runtimeFunction","returnValue","filter","frag","InterpreterOk","frags","isRunning","setIsRunning","interpreter","result","useInterpreter","disabled","RunButton","Interpreter","InterpreterErr","memoryManager","readString","string","encodedChar","writeString","WRAPPED_EXPORTS","WeakMap","isPromise","obj","then","proxyGet","transform","Proxy","Asyncify","dataAddr","dataEnd","dataStart","state","exports","fn","asyncify_stop_rewind","assertNoneState","asyncify_start_unwind","promise","module","wrapImportFn","imports","moduleImports","wrapModuleImports","newExport","asyncify_stop_unwind","asyncify_start_rewind","newExports","create","exportName","startsWith","wrapExportFn","defineProperty","enumerable","instance","Int32Array","buffer","wrapExports","setPrototypeOf","Instance","prototype","wrapImports","WebAssembly","instantiate","source","binary","instanceImports","wasmInstance","main","tigermain_wrapper","execution","end","slicedString","str1Pointer","str2Pointer","str1","str2","exit","alloc_array","alloc_record","check_index_array","check_nil","str_equals","str_not_equals","str_less","str_less_or_equals","str_greater","str_greater_or_equals","Memory","initial","maximum","Uint8Array","externals","WasmEvaluator","binaryWasm","wasmModule","binaryen","readBinary","setOptimizeLevel","runPasses","emitBinary","EvaluatorOk","bin","evaluator","from","useEvaluator","ErrorBoundary","errorInfo","fallback","React","Component","Evaluator","EvaluatorError","Tab","Tabs","selectedIndex","setSelectedIndex","names","Children","child","anyChild","isNil","visibleTab","toArray","TabsButtons","TabButton","selectedClass","moveToTab","altKey","WASMViewer","wat","emitText","useWatFromWasm","CompilerInterface","compile","compileResult","err","typecheck","escape","translate","wasm","useCompileResult","AsyncCompiler","lazy","default","Compiler","Header","App","ReactDOM","render","getElementById"],"mappings":"ihBAEaA,EAAuB,SAChCC,EACAC,GAC+C,MAETC,oBAAY,WAC9C,IACI,IAAMC,EAAsBC,OAAOC,aAAaC,QAAQN,GAExD,OAAOG,EAAOI,KAAKC,MAAML,GAAQF,EACnC,MAAOQ,GAGL,OADAC,QAAQC,IAAIF,GACLR,MAVgC,mBAExCW,EAFwC,KAE3BC,EAF2B,KAezCC,EAAoDC,uBACtD,SAACC,GACG,IAEI,IAAMC,EAAkBD,aAAiBE,SAAWF,EAAMJ,GAAeI,EAEzEH,EAAeI,GAEfb,OAAOC,aAAac,QAAQnB,EAAKO,KAAKa,UAAUH,IAClD,MAAOR,GAELC,QAAQW,KAAKZ,MAGrB,CAACT,EAAKY,IAGV,MAAO,CAACA,EAAaE,ICrCZQ,EAAQ,2E,kCCYfC,EAA2B,CAC7B,gBCbW,8IDcX,mBEdW,+HFeX,iBGfW,kIHgBX,eIhBW,ovBJiBX,iBKjBW,8lELkBX,aMlBW,02BCOFC,EAAoC,SAAC,GAAiB,IAAfC,EAAc,EAAdA,QAAc,EPmBvC,WAAiE,IAAD,EACvD1B,EANf,kBAMkEwB,GADI,mBAChFG,EADgF,KACtEC,EADsE,KAgBvF,MAAO,CAACD,EAbY,SAACE,EAAcC,GAC/BF,EAAY,eACLD,EADI,eAENE,EAAOC,MAIM,SAACD,GACyBF,EAAnCE,GADkC,IACfE,EADc,YACEJ,EADF,CACjCE,GADiC,UAG1CD,EAAYG,KO/BGC,GAAZL,EADuD,oBAG9D,OACI,yBAAKM,UAAU,2BACX,wCACA,wBAAIA,UAAU,iBACTC,OAAOC,QAAQR,GAAUS,KAAI,YAA0B,IAAD,mBAAvBC,EAAuB,KAAbC,EAAa,KACnD,OACI,kBAAC,EAAD,CACIrC,IAAKoC,EACLA,SAAUA,EACVC,QAASA,EACTZ,QAASA,UAc/Ba,EAA0C,SAAC,GAAoC,IAAlCF,EAAiC,EAAjCA,SAAUC,EAAuB,EAAvBA,QAASZ,EAAc,EAAdA,QAKlE,OACI,4BACI,4BAAQc,QANA,WACZd,EAAQY,KAKuBD,KC3B1BI,G,qBAAwC,SAACC,GAAW,ICZrCC,EAA2BC,EDa3CC,EAAgBH,EAAhBG,YADoD,EAGpC7C,EAA6B,cAAeuB,GAHR,mBAGrDO,EAHqD,KAG/CJ,EAH+C,KCZpCiB,EDiBZ,CAAC,GAAI,ICjBkCC,EDiB7B,kBAAMC,EAAYf,IChBxCgB,qBAAU,WACN,IAAMC,EAAa,SAACC,GACZL,EAAgBM,SAASD,EAAEE,UAAYF,EAAEG,UACzCP,IACAI,EAAEI,mBAMV,OAFAC,SAASC,iBAAiB,UAAWP,GAE9B,WACHM,SAASE,oBAAoB,UAAWR,MAE7C,CAACH,EAASD,IDWb,OACI,yBAAKV,UAAU,yBACX,kBAAC,EAAD,CAAUP,QAASA,IACnB,kBAAC,IAAD,CACI8B,KAAK,SACLC,MAAM,UACNC,SAAU,SAACC,GAAD,OAAajC,EAAQiC,IAC/B1C,MAAOa,EACPD,KAAK,cACL+B,YAAa,CAAEC,iBAAiB,GAChCC,MAhBwB,CAChCC,OAAQ,QACRC,SAAU,OACVC,MAAO,OAcCC,iBAAiB,EACjBC,OAAQ,SAACC,GAAD,OAA0BA,EAAOC,SACzCC,OAAQ,kBAAMzB,EAAYf,S,iBE9B7ByC,G,OAAsC,SAAC7B,GAAW,IACnD8B,EAAQ9B,EAAR8B,IAER,OAAY,OAARA,EAEI,6BACI,+CACA,wDACA,6FAID,kBAAC,EAAD,CAAaA,IAAKA,MAI3BC,EAAwC,SAAC/B,GAAW,IAC9C8B,EAAQ9B,EAAR8B,IAD6C,EAGvBrE,mBAAuB,CACjDuE,WAAW,EACXC,eAAe,EACfC,WAAW,EACXC,aAAa,IAPoC,mBAG9CC,EAH8C,KAGrCC,EAHqC,KAU/CC,EAAYC,mBAAQ,kBC7BN,SAAXC,EAAYV,GAA+C,IAArCM,EAAoC,uDAAZ,GAAY,EAM/DA,EAJAJ,iBAF+D,WAM/DI,EAHAH,qBAH+D,WAM/DG,EAFAF,iBAJ+D,WAM/DE,EADAD,mBAL+D,SASnE,GAAmB,kBAARL,IAAqBW,MAAMC,QAAQZ,IAAgB,OAARA,EAAc,CAChE,IAAMQ,EAAiB,GA4BvB,OA1BA9C,OAAOmD,KAAKb,GAAKc,SAAQ,SAACC,GAEtB,GAAU,SAANA,GAAgBX,EAApB,CACI,IAAMY,EAAWtD,OAAOmD,KAAKb,EAAG,MAAU,GAC1CQ,EAAUQ,GAAYN,EAASV,EAAG,KAASgB,GAAWV,OAKhD,QAANS,GAAeZ,GAKT,QAANY,GAAeb,GAKT,WAANa,GAAkBV,IAItBG,EAAUO,GAAKL,EAASV,EAAIe,GAAIT,OAG7BE,EAIX,MAAmB,kBAARR,GAAoBW,MAAMC,QAAQZ,GAClCA,EAAIpC,KAAI,SAACqD,GAAD,OAAUP,EAASO,EAAMX,MAIrCN,EDlByBU,CAASV,EAAKM,KAAU,CAACN,EAAKM,IAGxDY,EAAaxD,OAAOmD,KAAKL,GAAWW,OAAS,EAEnD,OACI,yBAAK1D,UAAU,cACX,kBAAC,IAAD,CACI2D,IAAKZ,EACLvB,MAAM,UACNoC,iBAAiB,EACjBC,mBAAmB,EACnBC,kBAAkB,IAErBL,GAAc,kBAAC,EAAD,CAAeZ,QAASA,EAASC,WAAYA,MAUlEiB,EAA8C,SAAC,GAA6B,IAA3BlB,EAA0B,EAA1BA,QAASC,EAAiB,EAAjBA,WAAiB,EAC3C5E,oBAAkB,GADyB,mBACtE8F,EADsE,KAC3DC,EAD2D,KAIvEC,EAAgB,4BAAwBF,EAAY,YAAc,YAExE,OACI,yBAAKhE,UAAU,4BACX,4BAAQA,UAAU,kBAAkBO,QANrB,kBAAM0D,GAAcD,KAO9BA,EAAY,UAAY,YAE7B,yBAAKhE,UAAWkE,GACXjE,OAAOC,QAAQ2C,GAAS1C,KAAI,YAAsB,IAAD,mBAAnBgE,EAAmB,KAAXnF,EAAW,KAE9C,OACI,yBAAKgB,UAAU,kBAAkBhC,IAAKmG,GAClC,2BACIC,GAAID,EACJE,KAAK,WACLC,QAAStF,EACTyC,SAPK,kBAAMqB,EAAW,eAAKD,EAAN,eAAgBsB,GAAUnF,QASnD,2BAAOuF,QAASJ,GAASA,UE1ExCK,EAAwC,SAAC/D,GAAW,IACrDgE,EAAchE,EAAdgE,UAER,OAAkB,OAAdA,EAEI,6BACI,qDACA,wDACA,kGAGiBC,IAAlBD,EAAUE,IAEb,6BACI,qDACA,+FAID,kBAAC,EAAD,CAAcF,UAAWA,KAI3BG,EAA0C,SAACnE,GAAU,IAEtDgE,EAAchE,EAAdgE,UAER,OACI,yBAAKzE,UAAU,eACX,kBAAC,IAAD,CACI2D,IAAKc,EACLjD,MAAM,UACNoC,iBAAiB,EACjBC,mBAAmB,EACnBC,kBAAkB,MClCrBe,EAA0C,SAACpE,GAAW,IACvDqE,EAAUrE,EAAVqE,MAER,OAAc,OAAVA,EAEI,6BACI,qDACA,wDACA,6FAID,kBAAC,EAAD,CAAeA,MAAOA,KAIxBC,EAA4C,SAACtE,GAAU,IAExDqE,EAAUrE,EAAVqE,MAER,OACI,yBAAK9E,UAAU,gBACX,kBAAC,IAAD,CACI2D,IAAKmB,EACLtD,MAAM,UACNoC,iBAAiB,EACjBC,mBAAmB,EACnBC,kBAAkB,MCrBrBkB,G,OAA8C,SAACvE,GAAW,IAC3DwE,EAAsDxE,EAAtDwE,SAAUC,EAA4CzE,EAA5CyE,UAAWC,EAAiC1E,EAAjC0E,cAAeC,EAAkB3E,EAAlB2E,cAEtCC,EAAaC,iBAA8B,MAQjD,OAPAzE,qBAAU,WACN,IAAM0E,EAAUF,EAAWG,QACX,OAAZD,IACAA,EAAQE,UAAYF,EAAQG,iBAKhC,yBAAK1F,UAAU,iBAAiB2F,IAAKN,GAChCJ,EAAS9E,KAAI,SAACyF,EAAaC,GACxB,OAAO,kBAAC,EAAD,CAAmB7H,IAAK6H,GAAQD,MAE1CV,GAAa,kBAAC,EAAD,CAAcE,cAAeA,IAC1CD,GAAiB,kBAAC,EAAD,CAAkBC,cAAeA,OASzDU,EAAsD,SAACrF,GACzD,IAAMsF,EAAUtF,EAAMuF,SAEtB,OACI,yBAAKhG,UAAU,uBACX,0BAAMA,UAAU,UAxCb,KAyCH,yBAAKA,UAAU,WAAW+F,KAShCE,EAA4C,SAACxF,GAAW,IAAD,EAC3BvC,mBAAS,IADkB,mBAClD6H,EADkD,KACzCG,EADyC,KAiBzD,OACI,yBAAKlG,UAAU,uBACX,0BAAMA,UAAU,UArEb,KAsEH,2BACIA,UAAU,QACVmG,WAAW,EACX1E,SApBK,SAAC2E,GAAgD,IACtDpH,EAAUoH,EAAMC,OAAhBrH,MAERkH,EAAWlH,IAkBHA,MAAO+G,EACPO,WAhBO,SAACF,GAGJ,UAFIA,EAARpI,KAGJyC,EAAM2E,cAAcmB,YAAYR,IAa5BS,YAAY,MAMtBC,EAAgD,SAAChG,GAAW,IAAD,EAC/BvC,mBAAiB,IADc,mBACtD6H,EADsD,KAC7CG,EAD6C,KAW7D,OACI,yBAAKlG,UAAU,uBACX,0BAAMA,UAAU,UA/Fb,KAgGH,2BACIA,UAAU,QACVmG,WAAW,EACX1E,SAfK,SAAC2E,GAAgD,IACtDpH,EAAUoH,EAAMC,OAAhBrH,MACRkH,EAAWlH,GAEPA,EAAM0E,QAAU,GAChBjD,EAAM2E,cAAcmB,YAAYvH,EAAM,KAWlCA,MAAO+G,EACPS,YAAY,M,eCjGtBE,EAAiB,SAACC,GACpB,MAAM,IAAIC,MAAM,4CAGPC,EAAa,WAAkD,IAAD,EACvC3I,mBAAmB,CAAC,KADmB,mBAChE+G,EADgE,KACtD6B,EADsD,OAGrC5I,oBAAkB,GAHmB,mBAGhEgH,EAHgE,KAGrD6B,EAHqD,OAK7B7I,oBAAkB,GALW,mBAKhEiH,EALgE,KAKjD6B,EALiD,KAgEvE,MAAO,CAzDahE,mBAAQ,WAsDxB,OAAO,IAtDuB,iDAE1BuD,YAAqCG,EAFX,KAI1BO,MAAQ,WACJH,GAAY,SAACI,GAAD,MAAkB,CAAC,QALT,KAQ1BC,MAAQ,SAACR,GACLG,GAAY,SAACM,GACT,IAAMC,EAAW,YAAOD,GAMxB,OAJAC,EAAYA,EAAY3D,OAAS,GAAK2D,EAClCA,EAAY3D,OAAS,GACvB4D,OAAOX,EAAIY,QAAQ,OAAQ,OAEtBF,MAhBW,KAoB1BG,UAAY,SAACb,GACTG,GAAY,SAACM,GAAD,4BAAqBA,GAArB,CAAkCT,QArBxB,KAwB1Bc,KAAO,WACH,OAAO,IAAIC,SAAgB,SAACC,GACxBZ,GAAa,GAEb,EAAKR,YAAc,SAACI,GAChBG,GAAY,SAACM,GAAD,4BAAqBA,GAArB,CAAkCT,EAAK,QACnDI,GAAa,GAGbY,EAAQhB,QAjCM,KAsC1BiB,SAAW,WACP,OAAO,IAAIF,SAAgB,SAACC,GACxBX,GAAiB,GAEjB,EAAKT,YAAc,SAACI,GAChB,IAAMkB,EAAOlB,EAAI,GACjBG,GAAY,SAACM,GAAD,4BAAqBA,GAArB,CAAkCS,EAAM,QACpDb,GAAiB,GAGjBW,EAAQE,WAOzB,IAEkB5C,EAAUC,EAAWC,I,uBCvEjC2C,GAN4BlB,MAMzC,kDACI,WAAYhB,GAAe,uCAAD,OAChBA,QADgB,IAChBA,IAAO,+BAFrB,sBAA8CgB,SAMjCmB,EAAb,kDACI,WAAYnC,GAAe,uCAAD,OAChBA,QADgB,IAChBA,IAAO,sBAFrB,sBAAsCgB,QAMzBoB,EAAe,SAAIhJ,EAAsB4G,GAClD,QAAclB,IAAV1F,EACA,MAAM,IAAI8I,EAAyBlC,GAEnC,OAAO5G,GAIFiJ,EAAkB,SAACC,EAAoBtC,GAChD,IAAKsC,EACD,MAAM,IAAItB,MAAMhB,IASXuC,EAGT,aAAe,IAAD,gCAFdjI,aAEc,OAIdkI,IAAM,SAACpK,EAAagB,GAChB,IAAMqJ,EAAa,EAAKnI,QAAQoI,WAAU,SAACC,GAAD,OAAoBA,EAAMvK,IAAIgD,SAAShD,MAQjF,OANIqK,GAAc,EACd,EAAKnI,QAAQmI,GAAc,CAAErK,MAAKgB,SAElC,EAAKkB,QAAQsI,KAAK,CAAExK,MAAKgB,UAGtB,GAbG,KAgBdyJ,IAAM,SAACzK,GACH,IAAM0K,EAAa,EAAKxI,QAAQyI,MAAK,SAACJ,GAAD,OAAoBA,EAAMvK,IAAIgD,SAAShD,MAE5E,YAAmB0G,IAAfgE,OACA,EAEOA,EAAW1J,OArBtB4J,KAAK1I,QAAU,IClCjB2I,EAAsB,SAACC,GAEzB,OAPqB,SAAClJ,GAAD,MAAwB,CAC7CmJ,MAAOnJ,GAMAoJ,CAFqD,YAC7CF,EAD6C,QAKnDG,EAAwB,SAACC,GAClC,OAAOA,EAAQ/I,IAAI0I,ICXVM,EAAW,SAACC,GACrB,MAAO,QAASA,GAGPC,EAAY,SAACD,GACtB,MAAO,SAAUA,GAGRE,EAAY,SAACF,GACtB,MAAO,SAAUA,GAGRG,EAAa,SAACH,GACvB,MAAO,UAAWA,GAGTI,GAAW,SAACJ,GACrB,MAAO,QAASA,GAGPK,GAAa,SAACL,GACvB,MAAO,UAAWA,GCnBTM,GAAiB,SAACC,EAAaC,GACxC,IAAMvB,EAAasB,EAAKrB,WAAU,SAACc,GAC/B,OAAOK,GAAWL,IAAQA,EAAIS,QAAUD,KAG5C,IAAoB,IAAhBvB,EACA,MAAM,IAAIzB,MAAJ,gCAAmCgD,EAAnC,OAGV,OAAOvB,GAGEyB,GAAW,SAACC,GACrB,IAAMJ,EAAc,GAMpB,OAJAI,EAAS1G,SAAQ,SAAC2G,GACdL,EAAKnB,KAAL,MAAAmB,EAAI,YAASK,EAAQL,UAGlBA,GAGEM,GAAY,SAACC,EAAWC,EAAiBC,GAClD,OAAQF,GACJ,IAAK,OACD,OAAOC,EAAUC,EAErB,IAAK,QACD,OAAOD,EAAUC,EAErB,IAAK,MACD,OAAOD,EAAUC,EAErB,IAAK,MACD,OAAOC,KAAKC,MAAMH,EAAUC,GAEhC,IAAK,MACD,OAAOD,GAAWC,EAEtB,IAAK,KACD,OAAOD,GAAWC,EAEtB,IAAK,SACD,OAAOD,GAAWC,EAEtB,IAAK,SACD,OAAOD,IAAYC,EAEvB,IAAK,UACD,OAAOD,GAAWC,EAEtB,IAAK,MACD,OAAOD,EAAUC,EAErB,IAAK,KACD,OAAOG,OAAOJ,IAAYC,GAE9B,IAAK,KACD,OAAOG,OAAOJ,IAAYC,GAE9B,IAAK,KACD,OAAOG,OAAOJ,EAAUC,GAE5B,IAAK,KACD,OAAOG,OAAOJ,EAAUC,GAE5B,IAAK,KACD,OAAOG,OAAOJ,GAAWC,GAE7B,IAAK,KACD,OAAOG,OAAOJ,GAAWC,GAE7B,IAAK,MAED,OAAOG,OAAOJ,EAAUC,GAE5B,IAAK,MAED,OAAOG,OAAOJ,GAAWC,GAE7B,IAAK,MAED,OAAOG,OAAOJ,EAAUC,GAE5B,IAAK,MAED,OAAOG,OAAOJ,GAAWC,GAE7B,QACI,MAAM,IAAIrC,IC3FTyC,GAAY,SAACC,GACtB,MAAO,SAAUA,GAGRC,GAAe,SAACD,GACzB,MAAO,gBAAiBA,GCKfE,GAAa,SAACC,GACvB,MAAO,UAAWA,GAGTC,GAAY,SAACD,GACtB,MAAO,SAAUA,GAGRE,GAAa,SAACF,GACvB,MAAO,UAAWA,GAGTG,GAAc,SAACH,GACxB,MAAO,WAAYA,GAGVI,GAAa,SAACJ,GACvB,MAAO,UAAWA,GAGTK,GAAW,SAACL,GACrB,MAAO,QAASA,GAGPM,GAAY,SAACN,GACtB,MAAO,SAAUA,GAGRO,GAAY,SAACP,GACtB,MAAO,SAAUA,GCzCRQ,GACT,WAAqBC,GAAmB,yBAAnBA,YAGZC,GAAb,kDACI,WAAqBzF,EAAwB0F,GAAkB,IAAD,8BAC1D,8CAA+BA,EAA/B,qBAAmD1F,KADlCA,QAAyC,EAAjB0F,UAAiB,EADlE,sBAA0C3E,QAM7B4E,GAAb,kDACI,aAAe,uCACL,qCAFd,sBAAyC5E,QCFlC,IAGM6E,IAA6BpB,KAAKC,MAFlBoB,SAEwC,GCT9C,EDGQ,GCHR,IDUVC,GAAwB,EAAbF,GAEXG,GAAsBD,GAKtBE,GAIT,WAAoBC,GAAqB,IAAD,gCAApBA,SAAoB,KAHhCC,oBAGgC,OAFhCC,mBAEgC,OAKxCC,MAAQ,SAACC,GACLjE,EAAgBiE,EAAQ,EAAG,wBAC3B,IAAMX,EAAU,EAAKS,cAIrB,OAHA,EAAKA,eAAiBE,EACtBjE,EAAgB,EAAK+D,cAAgBL,GAAU,kBAC/C,EAAKI,eAAe3D,IAAImD,EAASW,GAC1BX,GAX6B,KAcxCY,gBAAkB,SAACZ,EAAiB1F,GAChC,IAAMuG,EAAY,EAAKL,eAAetD,IAAI8C,GAC1C,QAAkB7G,IAAd0H,EACA,MAAM,IAAIxF,MAAM,qBAEpB,GCxCe,EDwCXf,GAAmBuG,GAAavG,EAAQ,EACxC,MAAM,IAAIyF,GAAqBzF,EAAO0F,IApBN,KA0BxCc,UAAY,SAACC,EAAatN,GACtBuN,GAAgBD,GAEhB,EAAKR,OAAOQ,GAAe,IAARtN,EACnB,EAAK8M,OAAOQ,EAAM,IAAe,MAATtN,IAAuB,EAC/C,EAAK8M,OAAOQ,EAAM,IAAMtN,EAAS,KAAO,KAAQ,GAChD,EAAK8M,OAAOQ,EAAM,IAAMtN,EAAS,KAAO,KAAQ,IAhCZ,KAmCxCwN,QAAU,SAACF,GACPC,GAAgBD,GAEhB,IAAItN,EAAQ,EAAK8M,OAAOQ,GAKxB,OAJAtN,GAAS,EAAK8M,OAAOQ,EAAM,IAAM,EACjCtN,GAAS,EAAK8M,OAAOQ,EAAM,IAAM,GACjCtN,GAAS,EAAK8M,OAAOQ,EAAM,IAAM,IAzCG,KA8CxCG,UAAY,SAACH,EAAatN,GACtB0N,GAAgBJ,GAEhB,EAAKR,OAAOQ,GAAOtN,GAjDiB,KAoDxC2N,QAAU,SAACL,GAGP,OAFAI,GAAgBJ,GAET,EAAKR,OAAOQ,IAvDiB,KA0DxCM,eAAiB,SAACC,EAAeC,GAE7B,IADA,IAAMC,EAAS,GACNC,EAAI,EAAGA,EAAIF,EAAOE,IAAK,CAC5B,IAAMV,EAAMO,EClFD,EDkFSG,EACpBD,EAAOvE,KAAK,EAAKgE,QAAQF,IAG7B5N,QAAQC,IAAIoO,IAjEwB,KAoExCE,eAAiB,SAACJ,EAAeC,GAE7B,IADA,IAAMC,EAAS,GACNC,EAAI,EAAGA,EAAIF,EAAOE,IAAK,CAC5B,IAAMV,EAAMO,EA7EC,EA6EOG,EACpBD,EAAOvE,KAAK,EAAKmE,QAAQL,IAG7B5N,QAAQC,IAAIoO,GACZrO,QAAQC,IAAIoO,EAAO5M,KAAI,SAACnB,GAAD,OAAWkO,OAAOC,aAAanO,QA3EtD4J,KAAKoD,cAAgBP,GACrB7C,KAAKmD,eAAiB,IAAIqB,KA8E5Bb,GAAkB,SAACD,GACrBrE,EAAgBqE,GAAO,GAAKA,EAAMX,GCtGf,EDsGJ,gBAAgDW,EAAhD,mBAGbI,GAAkB,SAACJ,GACrBrE,EAAgBqE,GAAO,GAAKA,EAAMX,GA3Fb,EA2FN,gBAAkDW,EAAlD,mBExGNe,GAAb,4MACYC,YAAsB7B,GADlC,EAIWQ,MAAQ,SAACC,GACZjE,EAAgBiE,EAAQ,EAAG,wBAC3B,IAAMqB,EAAW,EAAKD,YAEtB,OADA,EAAKA,aDTU,ECSKpB,EACbqB,GARf,wBAA4BH,MCQfI,GAGT,WAAoBC,EAAwBC,GAA+B,IAAD,gCAAtDD,SAAsD,KAA9BC,WAA8B,KAFlEC,QAAoB,GAE8C,KAE1EC,YAAc,SAACC,GAAoC,IAAD,cACzBA,EAAWC,YADc,GACvClE,EADuC,KAChCjD,EADgC,KAGxCoH,EAAO,EAAKC,qBAAqBrH,GAIvC,OAFA,EAAK+G,SAAStF,IAAIwB,EAAOmE,GAElBA,GAT+D,KAY1EC,qBAAuB,SAACrH,GACpB,IAAMoH,EAAO,EAAKN,OAAOxB,MAAM,GAC/B,EAAK0B,QAAQnF,KAAK7B,GAClB,IAAM4E,EAAU,EAAKoC,QAAQjK,OAAS,EAItC,OAFA,EAAK+J,OAAOrF,IAAI2F,EAAMxC,GAEfwC,GAnB+D,KAsB1EE,WAAa,SAACF,GACV,IAAMxC,EAAUvD,EAAa,EAAKyF,OAAOhF,IAAIsF,IAC7C,OAAO,EAAKJ,QAAQpC,KCDf2C,GAIT,WACYT,EACAU,EACA/I,GACT,IAAD,gCAHUqI,SAGV,KAFUU,gBAEV,KADU/I,gBACV,KAPMgJ,aAON,OANMC,gBAMN,OA4BFC,YAAc,SAAC1O,GACX,OAAO,EAAKwO,QAAQxO,IA7BtB,KAgCF2O,iBAAmB,SAAC3O,GAChB,OAAO,EAAKwO,QAAQxO,IAjCtB,KAwCMuH,MAAyB,SAACqH,GAAU,IACjCC,EADgC,YAClBD,EADkB,MAEvCxG,EAAayG,GAEb,IAAM9H,EAAM,EAAKwH,cAAcF,WAAWQ,GAG1C,OAFA,EAAKrJ,cAAc+B,MAAMR,GAElB,GA/CT,KAkDM+H,MAAyB,SAACF,GAC9B,OAAO,GAnDT,KAsDMG,QAtDN,uCAsDsC,WAAOH,GAAP,eAAAI,EAAA,sEAClB,EAAKxJ,cAAcwC,WADD,cAC9BjB,EAD8B,yBAE7B,EAAKwH,cAAcH,qBAAqBrH,EAAI,KAFf,2CAtDtC,2DA2DMkI,UA3DN,uCA2DwC,WAAOL,GAAP,eAAAI,EAAA,sEACpB,EAAKxJ,cAAcqC,OADC,cAChCd,EADgC,yBAE/B,EAAKwH,cAAcH,qBAAqBrH,IAFT,2CA3DxC,2DAgEMmI,IAAuB,SAACN,GAAU,IAC/BC,EAD8B,YAChBD,EADgB,MAMrC,OAJAxG,EAAayG,GAED,EAAKN,cAAcF,WAAWQ,GAE/BM,WAAW,IAtExB,KAyEMC,IAAuB,SAACR,GAAU,IAC/BS,EAD8B,YAClBT,EADkB,MAErCxG,EAAaiH,GAEb,IAAMtI,EAAMuG,OAAOC,aAAa8B,GAChC,OAAO,EAAKd,cAAcH,qBAAqBrH,IA9EjD,KAiFMuI,KAAwB,SAACV,GAAU,IAChCC,EAD+B,YACjBD,EADiB,MAKtC,OAHAxG,EAAayG,GAED,EAAKN,cAAcF,WAAWQ,GAC/B/K,QAtFb,KAyFMyL,UAA6B,SAACX,GAAU,IAAD,cACRA,EADQ,GACpCC,EADoC,KACxB5B,EADwB,KACjBC,EADiB,KAE3C9E,EAAayG,GAEb,IACMW,EADM,EAAKjB,cAAcF,WAAWQ,GACpBY,MAAMxC,EAAOC,GAEnC,OAAO,EAAKqB,cAAcH,qBAAqBoB,IAhGjD,KAmGM9H,OAA0B,SAACkH,GAAU,IAAD,cACEA,EADF,GACjCc,EADiC,KACjBC,EADiB,KAExCvH,EAAasH,GACbtH,EAAauH,GAEb,IAEMC,EAFU,EAAKrB,cAAcF,WAAWqB,GAC7B,EAAKnB,cAAcF,WAAWsB,GAG/C,OAAO,EAAKpB,cAAcH,qBAAqBwB,IA5GjD,KA+GMC,IAAuB,SAACjB,GAAU,IAC/BxP,EAD8B,YACrBwP,EADqB,MAIrC,OAFAxG,EAAahJ,GAENuL,QAAQvL,IAnHjB,KAsHM0Q,WAA8B,SAAClB,GAAU,IAAD,cACnBA,EADmB,GACrCjD,EADqC,KAC5BoE,EAD4B,KAE5C3H,EAAauD,GACbvD,EAAa2H,GAEb,IAAK,IAAI3C,EAAI,EAAGA,EAAI2C,EAAO3C,IAAK,CAC5B,IAAM4C,EAAerE,EHxKV,EGwKoByB,EAE/BtO,QAAQC,IAAI,EAAK8O,OAAOhF,IAAImH,IAGhC,OAAO,GAjIT,KAoIMC,WAA8B,SAACrB,GAAU,IAAD,cACnBA,EADmB,GACrCjD,EADqC,KAC5BW,EAD4B,KAE5ClE,EAAauD,GACbvD,EAAakE,GAEb,IAAK,IAAIc,EAAI,EAAGA,EAAId,EAAOc,IAAK,CAC5B,IAAM4C,EAAerE,EJvKR,EIuKkByB,EAE/BtO,QAAQC,IAAI,EAAK8O,OAAOhF,IAAImH,IAGhC,OAAO,GA/IT,KAsJME,WAA8B,SAACtB,GAAU,IAAD,cACvBA,EADuB,GACrCU,EADqC,KAC/Ba,EAD+B,KAE5C/H,EAAakH,GACblH,EAAa+H,GAEb,IAAMC,EAAgB,EAAKvC,OAAOxB,MHvMnB,EGuMyBiD,GACxC,EAAKb,WAAWjG,IAAI4H,EAAed,GAEnC,IAAK,IAAIlC,EAAI,EAAGA,EAAIkC,EAAMlC,IAAK,CAC3B,IAAM4C,EAAeI,EH3MV,EG2M0BhD,EAErC,EAAKS,OAAOrF,IAAIwH,EAAcG,GAGlC,OAAOC,GApKT,KAuKMC,gBAAmC,SAACzB,GAAU,IAAD,cACxBA,EADwB,GAC1CjD,EAD0C,KACjC1F,EADiC,KAEjDmC,EAAauD,GACbvD,EAAanC,GAEb,IAAMqJ,EAAO,EAAKb,WAAW5F,IAAI8C,GAEjC,GAAI1F,EAAQ,GAAKA,GAASmC,EAAakH,GACnC,MAAM,IAAI5D,GAAqBzF,EAAO0F,GAG1C,OAAO,GAlLT,KAqLM2E,SAA4B,SAAC1B,GAAU,IACpC2B,EADmC,YACzB3B,EADyB,MAI1C,GAFAxG,EAAamI,GAEE,IAAXA,EACA,MAAM,IAAI3E,GAGd,OAAO,GA7LT,KAgMM4E,YAA+B,SAAC5B,GAAU,IACvCU,EADsC,YAC9BV,EAD8B,MAM7C,OAJAxG,EAAakH,GAEU,EAAKzB,OAAOxB,MHhPpB,EGgP0BiD,IApM3C,KAyMMmB,UAA6B,SAAC7B,GAClC,IAAM8B,EAAa,EAAKC,WAAW/B,GACnC,OAAOjE,OAAsB,IAAf+F,IA3MhB,KA8MME,aAAgC,SAAChC,GACrC,IAAM8B,EAAa,EAAKC,WAAW/B,GACnC,OAAOjE,OAAsB,IAAf+F,IAhNhB,KAmNMG,QAA2B,SAACjC,GAChC,IAAM8B,EAAa,EAAKC,WAAW/B,GACnC,OAAOjE,OAAO+F,EAAa,IArN7B,KAwNMI,gBAAmC,SAAClC,GACxC,IAAM8B,EAAa,EAAKC,WAAW/B,GACnC,OAAOjE,OAAO+F,GAAc,IA1N9B,KA6NMK,WAA8B,SAACnC,GACnC,IAAM8B,EAAa,EAAKC,WAAW/B,GACnC,OAAOjE,OAAO+F,EAAa,IA/N7B,KAkOMM,mBAAsC,SAACpC,GAC3C,IAAM8B,EAAa,EAAKC,WAAW/B,GACnC,OAAOjE,OAAO+F,GAAc,IApO9B,KAwOMC,WAA8B,SAAC/B,GAAU,IAAD,cACFA,EADE,GACrCc,EADqC,KACrBC,EADqB,KAGtCsB,EAAU,EAAK1C,cAAcF,WAAWjG,EAAasH,IACrDwB,EAAW,EAAK3C,cAAcF,WAAWjG,EAAauH,IAE5D,OAAOsB,EAAQE,cAAcD,IA7O7BlI,KAAKyF,WAAa,IAAIjB,IACtBxE,KAAKwF,QAAU,CACXjH,MAAOyB,KAAKzB,MACZuH,MAAO9F,KAAK8F,MACZC,QAAS/F,KAAK+F,QACdE,UAAWjG,KAAKiG,UAChBC,IAAKlG,KAAKkG,IACVE,IAAKpG,KAAKoG,IACVE,KAAMtG,KAAKsG,KACXC,UAAWvG,KAAKuG,UAChB7H,OAAQsB,KAAKtB,OACbmI,IAAK7G,KAAK6G,IACVuB,YAAapI,KAAK8G,WAClBuB,YAAarI,KAAKiH,WAClB,eAAgBjH,KAAKkH,WACrB,gBAAiBlH,KAAKwH,YACtB,cAAexH,KAAKyH,UACpB,kBAAmBzH,KAAK4H,aACxB,YAAa5H,KAAK6H,QAClB,sBAAuB7H,KAAK8H,gBAC5B,eAAgB9H,KAAK+H,WACrB,yBAA0B/H,KAAKgI,mBAC/B,qBAAsBhI,KAAKqH,gBAC3B,aAAcrH,KAAKsH,WCxClBgB,GAsBT,WAAYzM,EAA2BW,GAA+B,IAAD,gCAA9BA,gBAA8B,KApB7D+L,YAoB6D,OAjB7DC,aAiB6D,OAd7DC,YAc6D,OAX7DC,SAW6D,OAR7DnD,mBAQ6D,OAL7DoD,eAK6D,OAF7DC,aAE6D,OAmB9DC,IAnB8D,sBAmBxD,sBAAA7C,EAAA,4DAES,aAFT,SAGI,EAAK8C,aADA,aACwB,CAAC,IAHlC,mFAnBwD,KAyB7DA,aAzB6D,uCAyB9C,WAAO9R,EAAc4O,GAArB,+BAAAI,EAAA,6DAEbnE,EAAWzC,EACb,EAAKuJ,UAAU9I,IAAI7I,GADM,yCAESA,EAFT,MAFV,EAMK6K,EAASkH,KAAzBC,EANW,EAMXA,KAAMC,EANK,EAMLA,MAGRC,EAAkB,EAAKX,OAC7B,EAAKA,OAAS,IAAI/D,IAGZ2E,EAba,UAaJ,EAAKX,QAAQ3I,IAAI,aAbb,QAasB,EACzC,EAAK2I,QAAQhJ,IAAI,KAAM2J,EA/DF,SAiDF,SAiBb,EAAKC,aAAaxD,EAAMqD,EAAM3I,SAjBjB,wBAoBb,EAAK+I,SAASnI,GAAS8H,IApBV,eAuBnB,EAAKT,OAASW,EAGRI,EA1Ba,UA0BR,EAAKd,QAAQ3I,IAAI,aA1BT,QA0BkB,EAErC,EAAK2I,QAAQhJ,IAAI,KAAM2J,GA5BJ,kBA8BZG,GA9BY,4CAzB8C,6DA8D7DD,SA9D6D,uCA8DlD,WAAOtI,GAAP,qBAAAiF,EAAA,sDAEXuD,EAAmB,EAFR,YAIRA,EAAmBxI,EAAKjG,QAJhB,wBAKL0F,EAAMO,EAAKwI,GALN,SAQ4B,EAAKC,QAAQhJ,GARzC,UAWQ,QAHbiJ,EARK,yBAaPF,IAbO,2BAce,SAAfE,EAdA,qDAmBDC,EAAe5I,GAAeC,EAAM0I,GAC1CF,EAAmBG,EApBZ,mEA9DkD,2DAwF7DN,aAxF6D,uCAwF9C,WAAOxD,EAAgBtF,GAAvB,qBAAA0F,EAAA,sDACb2D,EAAatJ,EAAsBC,GAEhC8D,EAAI,EAHM,YAGHA,EAAIwB,EAAK9K,QAHN,oBAIT8O,EAAMhE,EAAKxB,GACXyF,EAASF,EAAWvF,IAEtBjC,GAAY0H,GAPD,gBASX,EAAKrB,QAAQhJ,IAAIqK,EAAOC,OAAQF,GATrB,2BAUJ1H,GAAW2H,GAVP,iBAYX,EAAKtB,OAAO/I,IAAIqK,EAAO1J,MAAOyJ,GAZnB,8BAeL,IAAIzK,EAfC,QAGciF,IAHd,2DAxF8C,6DAgH7DoF,QAhH6D,uCAgHnD,WAAOhJ,GAAP,iDAAAwF,EAAA,0DACVzF,EAASC,GADC,gCAEJ,EAAKuJ,QAAQvJ,EAAIwJ,KAFb,gCAGH,MAHG,WAMVvJ,EAAUD,GANA,kCAOeA,EAAIyJ,KAPnB,GAOHC,EAPG,KAOIC,EAPJ,MAQNjI,GAAWgI,GARL,iCASsB,EAAKH,QAAQI,GATnC,cASA/T,EATA,OAWN,EAAKmS,OAAO/I,IAAI0K,EAAM/J,MAAO/J,GAXvB,kBAYC,MAZD,YAeN+L,GAAY+H,GAfN,kCAgBsB,EAAKH,QAAQI,GAhBnC,eAgBA/T,EAhBA,OAkBN,EAAKoS,QAAQhJ,IAAI0K,EAAMJ,OAAQ1T,GAlBzB,kBAmBC,MAnBD,YAsBNiM,GAAS6H,GAtBH,kCAuByB,EAAKH,QAAQG,EAAME,KAvB5C,eAuBAC,EAvBA,iBAwBsB,EAAKN,QAAQI,GAxBnC,eAwBA/T,EAxBA,OA0BN,EAAKsS,IAAIlJ,IAAI6K,EAAUjU,GA1BjB,kBA2BC,MA3BD,cA8BJ,IAAI+I,EAAJ,yDAAuE+K,EAAvE,OA9BI,YAiCVxJ,EAAUF,GAjCA,kCAkCMA,EAAI8J,KAlCV,GAkCHC,EAlCG,MAmCNtI,GAAUsI,GAnCJ,0CAoCCA,EAAMC,MApCP,cAuCJ,IAAIrL,EAAJ,2CAAyDoL,EAAzD,OAvCI,YA0CV5J,EAAWH,GA1CD,sCA2C6CA,EAAIiK,MA3CjD,GA2CHnJ,EA3CG,KA2CCoJ,EA3CD,KA2CUC,EA3CV,KA2CoBC,EA3CpB,KA2C+BC,EA3C/B,eA6CY,EAAKd,QAAQW,GA7CzB,eA6CJnJ,EA7CI,iBA8Ca,EAAKwI,QAAQY,GA9C1B,eA8CJnJ,EA9CI,OAiDJlC,EAAY+B,GAAUC,EAAIC,EAASC,GAjD/B,kBAkDW,IAAdlC,EAAkBuL,EAAaD,GAlD5B,YAqDVhK,GAASJ,GArDC,uBAsDJ,IAAIrB,EAAiB,oCAtDjB,YAyDV0B,GAAWL,GAzDD,0CA0DH,MA1DG,cA8DR,IAAIrB,EA9DI,4CAhHmD,2DAqL7D4K,QArL6D,uCAqLnD,WAAO/H,GAAP,yCAAAgE,EAAA,0DACVjE,GAAWC,GADD,yCAEHA,EAAI8I,OAFD,WAKV7I,GAAUD,GALA,yCAMH5C,EACH,EAAKqJ,OAAO5I,IAAImC,EAAIwI,MADL,uCAEiBxI,EAAIwI,KAFrB,OANT,WAYVtI,GAAWF,GAZD,yCAaH5C,EACH,EAAKmJ,OAAO1I,IAAImC,EAAI7B,OADL,uCAEiB6B,EAAI7B,MAFrB,OAbT,WAmBVgC,GAAYH,GAnBF,yCAoBH5C,EACH,EAAKoJ,QAAQ3I,IAAImC,EAAI8H,QADN,wCAEkB9H,EAAI8H,OAFtB,OApBT,WA0BV1H,GAAWJ,GA1BD,sCA2BsBA,EAAI+I,MA3B1B,GA2BHzJ,EA3BG,KA2BCoJ,EA3BD,KA2BUC,EA3BV,eA6BY,EAAKZ,QAAQW,GA7BzB,eA6BJnJ,EA7BI,iBA8Ba,EAAKwI,QAAQY,GA9B1B,eA8BJnJ,EA9BI,yBAgCHH,GAAUC,EAAIC,EAASC,IAhCpB,YAmCVa,GAASL,GAnCC,kCAoCQ,EAAK+H,QAAQ/H,EAAIoI,KApCzB,eAoCJ1G,EApCI,yBAqCHtE,EAAa,EAAKsJ,IAAI7I,IAAI6D,GAAd,0BAAuCA,EAAvC,gBArCT,YAwCVpB,GAAUN,GAxCA,kCAyCeA,EAAIgJ,KAzCnB,GAyCHC,EAzCG,KAyCOrF,EAzCP,MA0CN3D,GAAUgJ,GA1CJ,wBA2CAjU,EAAOiU,EAAST,KA3ChB,UA4CsB1L,QAAQoM,IAAItF,EAAKrO,IAAI,EAAKwS,UA5ChD,WA4CAoB,EA5CA,YAgDkBrP,KADlBsP,EAAkB,EAAKxC,QAAQjD,iBAAiB3O,IA/ChD,kCAiDkBoU,EAAgBD,GAjDlC,QAiDFE,EAjDE,gDAmDkB,EAAKvC,aAAa9R,EAAMmU,GAnD1C,QAmDFE,EAnDE,sBAsDN,EAAK7C,QAAQhJ,IAAI,KAAM6L,GAtDjB,kBAwDCA,GAxDD,cA0DA,IAAIlM,EAAiB,8BA1DrB,YA8DVoD,GAAUP,GA9DA,uBA+DJ,IAAI7C,EAAiB,qCA/DjB,cAmER,IAAIA,EAnEI,4CArLmD,sDACjEa,KAAKuI,OAAS,IAAI/D,IAClBxE,KAAKwI,QAAU,IAAIhE,IACnBxE,KAAKyI,OAAS,IAAIjE,IAClBxE,KAAK0I,IAAM,IAAIjE,GACfzE,KAAKuF,cAAgB,IAAIX,GAAc5E,KAAK0I,IAAK1I,KAAKyI,QACtDzI,KAAK2I,UAAY,IAAIpJ,EAErB1D,EAAUyP,OAAO1J,IAAWnH,SAAQ,SAAC8Q,GACjC,EAAK5C,UAAUnJ,IAAI+L,EAAKxC,KAAKE,MAAMjI,MAAOuK,MAG9C1P,EAAUyP,OAAOxJ,IAAcrH,SAAQ,SAAC8Q,GACpC,EAAKhG,cAAcP,YAAYuG,MAGnCvL,KAAK4I,QAAU,IAAItD,GAAQtF,KAAK0I,IAAK1I,KAAKuF,cAAevF,KAAKxD,gBC1DzDgP,GAA8C,SAAC3T,GAAW,IAC3D4T,EAAU5T,EAAV4T,MAD0D,EAENxN,IAFM,mBAE3DzB,EAF2D,KAE5CH,EAF4C,KAElCC,EAFkC,KAEvBC,EAFuB,OCFxC,SAC1BC,EACAiP,GAC0B,IAAD,EACSnW,oBAAkB,GAD3B,mBAClBoW,EADkB,KACPC,EADO,KAGnBC,EAAcxR,mBAAQ,kBAAM,IAAIkO,GAAgBmD,EAAOjP,KAAgB,CACzEiP,EACAjP,IA4BJ,MAAO,CAzBKrG,sBAAW,sBAAC,4BAAA6P,EAAA,6DACpBxJ,EAAc6B,QACdsN,GAAa,GAFO,kBAIKC,EAAY/C,MAJjB,OAIVgD,EAJU,OAKhBrP,EAAcoC,UAAd,kCAAmDiN,IALnC,gDAOZ,gBAAenJ,GACflG,EAAc+B,MAAd,2EACwE,KAAItB,MAD5E,yBACkG,KAAI0F,UAE/F,gBAAeC,GACtBpG,EAAc+B,MAAd,kFAIAzI,QAAQD,MAAR,MACA2G,EAAc+B,MAAd,wCACqC,KAAIpB,QADzC,6CAjBY,QAsBpBwO,GAAa,GAtBO,yDAuBrB,CAACC,EAAapP,IAEJkP,GD9BYI,CAAetP,EAAeiP,GAJW,mBAI3D5C,EAJ2D,KAItD6C,EAJsD,KAMlE,OACI,yBAAKtU,UAAU,yBACX,kBAAC,EAAD,CACIoF,cAAeA,EACfH,SAAUA,EACVC,UAAWA,EACXC,cAAeA,IAEnB,kBAAC,GAAD,CAAWwP,SAAUL,EAAW/T,QAASkR,MAU/CmD,GAAsC,SAACnU,GACzC,OACI,4BAAQT,UAAU,aAAa2U,SAAUlU,EAAMkU,SAAUpU,QAASE,EAAMF,SAAxE,oBE3BKsU,I,OAA0C,SAACpU,GACpD,OAAoB,OAAhBA,EAAMqE,MACC,kBAAC,GAAD,MAEA,kBAAC,GAAD,CAAeuP,MAAO5T,EAAMqE,UAIrCgQ,GAA2B,WAC7B,OACI,yBAAK9U,UAAU,yBACX,qDACA,wDACA,8F,oBCpBCwN,GACT,WAAoBuH,GAA+B,IAAD,gCAA9BA,gBAA8B,KAElDC,WAAa,SAACvG,GAEV,IADA,IAAIwG,EAAS,GACJjI,EAAI,GAASA,IAAK,CACvB,IAAMkI,EAAc,EAAKH,cAAcpI,QAAQ8B,EAAazB,GAE5D,GAAoB,IAAhBkI,EACA,MAGJD,GAAU/H,OAAOC,aAAa+H,GAGlC,OAAOD,GAduC,KAiBlDE,YAAc,SAACxO,GAEX,IADA,IAAM4E,EAAU,EAAKwJ,cAAc9I,MAAMtF,EAAIjD,OAAS,GAC7CsJ,EAAI,EAAGA,EAAIrG,EAAIjD,OAAQsJ,IAAK,CACjC,IAAMiC,EAAWtI,EAAIoI,WAAW/B,GAChC,EAAK+H,cAActI,UAAUlB,EAAUyB,EAAGiC,GAI9C,OAFA,EAAK8F,cAActI,UAAUlB,EAAU5E,EAAIjD,OAAQ,GAE5C6H,I,qCC5BT6J,GAAkB,IAAIC,QAE5B,SAASC,GAAUC,GACf,QACMA,IACc,kBAARA,GAAmC,oBAARA,IACf,oBAAbA,EAAIC,KAInB,SAASC,GAASF,EAAKG,GACnB,OAAO,IAAIC,MAAMJ,EAAK,CAClB9M,IAAK,SAAC8M,EAAK3V,GAAN,OAAe8V,EAAUH,EAAI3V,O,IAIpCgW,G,WACF,WAAYC,EAAUC,GAAU,oBAC5BlN,KAAKiN,SAAWA,EAChBjN,KAAKkN,QAAUA,EACflN,KAAKmN,UAAYnN,KAAKiN,SAAW,EACjCjN,KAAKoN,MAAQ,CAAE3R,KAAM,WACrBuE,KAAKqN,QAAU,K,+DAIf,GAAwB,SAApBrN,KAAKoN,MAAM3R,KACX,MAAM,IAAIuC,MAAJ,8BAAiCgC,KAAKoN,MAAM3R,S,mCAI7C6R,GAAK,IAAD,OACb,OAAO,WACH,GAAwB,cAApB,EAAKF,MAAM3R,KAAsB,CAAC,IAC5BrF,EAAU,EAAKgX,MAAfhX,MAGN,OAFA,EAAKgX,MAAQ,CAAE3R,KAAM,QACrB,EAAK4R,QAAQE,uBACNnX,EAEX,EAAKoX,kBACL,IAAIpX,EAAQkX,EAAE,WAAF,aACZ,IAAKZ,GAAUtW,GACX,OAAOA,EAEX,EAAKiX,QAAQI,sBAAsB,EAAKR,UACxC,EAAKG,MAAQ,CACT3R,KAAM,YACNiS,QAAStX,M,wCAKHuX,GAAS,IAAD,OACtB,OAAOd,GAASc,GAAQ,SAACvX,GACrB,MAAqB,oBAAVA,EACA,EAAKwX,aAAaxX,GAEtBA,O,kCAIHyX,GAAU,IAAD,OACjB,QAAgB/R,IAAZ+R,EAEJ,OAAOhB,GAASgB,GAAS,SAACC,GAAD,OAAmB,EAAKC,kBAAkBD,Q,mCAG1DR,GAAK,IAAD,OACTU,EAAYxB,GAAgB3M,IAAIyN,GAEpC,YAAkBxR,IAAdkS,IAIJA,EAAS,uCAAG,4CAAAhI,EAAA,sDACR,EAAKwH,kBAED3B,EAASyB,EAAE,WAAF,KAHL,UAKmB,cAApB,EAAKF,MAAM3R,KALV,wBAMEiS,EAAY,EAAKN,MAAjBM,QACN,EAAKN,MAAQ,CAAE3R,KAAM,QACrB,EAAK4R,QAAQY,uBART,SAScP,EATd,OASAtX,EATA,OAUJ,EAAKoX,kBACL,EAAKH,QAAQa,sBAAsB,EAAKjB,UACxC,EAAKG,MAAQ,CACT3R,KAAM,YACNrF,SAEJyV,EAASyB,IAhBL,8BAmBR,EAAKE,kBAnBG,kBAqBD3B,GArBC,4CAAH,qDAwBTW,GAAgBhN,IAAI8N,EAAIU,IA3BbA,I,kCAgCHX,GACR,IAAIc,EAAa9W,OAAO+W,OAAO,MAE/B,IAAK,IAAIC,KAAchB,EAAS,CAC5B,IAAIjX,EAAQiX,EAAQgB,GACC,oBAAVjY,GAAyBiY,EAAWC,WAAW,eACtDlY,EAAQ4J,KAAKuO,aAAanY,IAE9BiB,OAAOmX,eAAeL,EAAYE,EAAY,CAC1CI,YAAY,EACZrY,UAMR,OAFAoW,GAAgBhN,IAAI6N,EAASc,GAEtBA,I,2BAGNO,EAAUb,GAAU,IACbR,EAAYqB,EAAZrB,QAEFnK,EAASmK,EAAQnK,QAAW2K,EAAQnF,KAAOmF,EAAQnF,IAAIxF,OAE7D,IAAIyL,WAAWzL,EAAO0L,OAAQ5O,KAAKiN,UAAUzN,IAAI,CAACQ,KAAKmN,UAAWnN,KAAKkN,UAEvElN,KAAKoN,MAAQ,CAAE3R,KAAM,QAErBuE,KAAKqN,QAAUrN,KAAK6O,YAAYxB,GAEhChW,OAAOyX,eAAeJ,EAAUK,GAASC,e,KAIpCD,GAAb,kDACI,WAAYpB,EAAQV,EAAUC,EAASW,GAAU,IAAD,sBAC5C,IAAIT,EAAQ,IAAIJ,GAASC,EAAUC,GADS,OAE5C,cAAMS,EAAQP,EAAM6B,YAAYpB,IAChCT,EAAMjG,KAAN,gBAAiB0G,GAH2B,EADpD,qDAQQ,OAAOrB,GAAgB3M,IAAhB,4DARf,GAA8BqP,YAAYH,UAcnC,SAAeI,GAAtB,yC,8CAAO,WAA2BC,EAAQnC,EAAUC,EAASW,GAAtD,iBAAA7H,EAAA,6DACCoH,EAAQ,IAAIJ,GAASC,EAAUC,GADhC,SAEgBgC,YAAYC,YAAYC,EAAQhC,EAAM6B,YAAYpB,IAFlE,cAEChC,EAFD,OAGHuB,EAAMjG,KAAK0E,aAAkBqD,YAAYH,SAAWlD,EAASA,EAAO6C,SAAUb,GAH3E,kBAIIhC,GAJJ,4C,sBAFPxU,OAAOmX,eAAeO,GAASC,UAAW,UAAW,CAAEP,YAAY,ICvI5D,IAAMnJ,GAKT,WAAoB+J,EAA4B7S,GAA+B,IAAD,gCAA1D6S,SAA0D,KAA9B7S,gBAA8B,KAJtE2P,mBAIsE,OAHtE5G,mBAGsE,OAFtE+J,qBAEsE,OAqC9EzG,IArC8E,sBAqCxE,gCAAA7C,EAAA,+EAE6BgH,GACvB,EAAKqC,OACLrM,GXnDaF,SWqDb,EAAKwM,iBANX,cAEQC,EAFR,OASQC,EAAOD,EAAab,SAASrB,QAAQoC,kBAT7C,SAU0BD,IAV1B,cAUQE,EAVR,yBAYSA,GAZT,uCAcM,gBAAelN,IAdrB,0CAea,KAAIC,UAfjB,6EArCwE,KA2DtElE,MAAQ,SAACsH,GACb,IAAMwG,EAAS,EAAK9G,cAAc6G,WAAWvG,GAE7C,OADA,EAAKrJ,cAAc+B,MAAM8N,GAClB,GA9DmE,KAgEtEvG,MAAQ,WACZ,OAAO,GAjEmE,KAmEtEC,QAnEsE,sBAmE5D,4BAAAC,EAAA,sEACO,EAAKxJ,cAAcwC,WAD1B,cACRqN,EADQ,yBAEP,EAAK9G,cAAcgH,YAAYF,IAFxB,2CAnE4D,KAuEtEpG,UAvEsE,sBAuE1D,4BAAAD,EAAA,sEACK,EAAKxJ,cAAcqC,OADxB,cACVwN,EADU,yBAET,EAAK9G,cAAcgH,YAAYF,IAFtB,2CAvE0D,KA2EtEnG,IAAM,SAACL,GAEX,OADe,EAAKN,cAAc6G,WAAWvG,GAC/BM,WAAW,IA7EiD,KA+EtEC,IAAM,SAACC,GACX,IAAMgG,EAAS/H,OAAOC,aAAa8B,GACnC,OAAO,EAAKd,cAAcgH,YAAYF,IAjFoC,KAmFtE/F,KAAO,SAACT,GAEZ,OADe,EAAKN,cAAc6G,WAAWvG,GAC/B/K,QArF4D,KAuFtEyL,UAAY,SAACV,EAAoB5B,EAAe0L,GACpD,IACMC,EADS,EAAKrK,cAAc6G,WAAWvG,GACjBY,MAAMxC,EAAO0L,GAEzC,OADsB,EAAKpK,cAAcgH,YAAYqD,IA1FqB,KA6FtElR,OAAS,SAACmR,EAAqBC,GACnC,IAAMC,EAAO,EAAKxK,cAAc6G,WAAWyD,GACrCG,EAAO,EAAKzK,cAAc6G,WAAW0D,GAE3C,OAAO,EAAKvK,cAAcgH,YAAYwD,EAAOC,IAjG6B,KAmGtEnJ,IAAM,SAACvH,GACX,OAAOqC,QAAQrC,IApG2D,KAsGtE2Q,KAAO,SAACxN,GACZ,MAAM,IAAID,GAAYC,IAvGoD,KAyGtEyN,YAAc,SAAC5J,EAAca,GAEjC,IADA,IAAMxE,EAAU,EAAKwJ,cAAc9I,MV3HpB,EU2H0BiD,GAChClC,EAAI,EAAGA,EAAIkC,EAAMlC,IAAK,CAC3B,IAAMV,EAAMf,EV7HD,EU6HWyB,EACtB,EAAK+H,cAAc1I,UAAUC,EAAKyD,GAGtC,OAAOxE,GAhHmE,KAkHtEwN,aAAe,SAAC7J,GACpB,IAAM3D,EAAU,EAAKwJ,cAAc9I,MVpIpB,EUoI0BiD,GAEzC,OADAxQ,QAAQC,IAAR,4BAAiC4M,IAC1BA,GArHmE,KAuHtEyF,YAAc,SAACzF,EAAiBoE,GAGpC,OAFAjR,QAAQC,IAAR,qBAA0BgR,EAA1B,+BAAsDpE,IACtD,EAAKwJ,cAAcnI,eAAerB,EAASoE,GACpC,GA1HmE,KA4HtEsB,YAAc,SAAC1F,EAAiBW,GAGpC,OAFAxN,QAAQC,IAAR,qBAA0BuN,EAA1B,+BAAsDX,IACtD,EAAKwJ,cAAc9H,eAAe1B,EAASW,GACpC,GA/HmE,KAiItE8M,kBAAoB,SAACzN,EAAiB1F,GAE1C,OADA,EAAKkP,cAAc5I,gBAAgBZ,EAAS1F,GACrC,GAnImE,KAqItEoT,UAAY,SAAC9I,GACjB,GAAe,IAAXA,EACA,MAAM,IAAI3E,GAEd,OAAO,GAzImE,KA2ItE0N,WAAa,SAAC5J,EAAwBC,GAC1C,IAAMe,EAAa,EAAKC,WAAWjB,EAAgBC,GAEnD,OAAOhF,OAAsB,IAAf+F,IA9I4D,KAgJtE6I,eAAiB,SAAC7J,EAAwBC,GAC9C,IAAMe,EAAa,EAAKC,WAAWjB,EAAgBC,GAEnD,OAAOhF,OAAsB,IAAf+F,IAnJ4D,KAqJtE8I,SAAW,SAAC9J,EAAwBC,GACxC,IAAMe,EAAa,EAAKC,WAAWjB,EAAgBC,GAEnD,OAAOhF,OAAO+F,EAAa,IAxJ+C,KA0JtE+I,mBAAqB,SAAC/J,EAAwBC,GAClD,IAAMe,EAAa,EAAKC,WAAWjB,EAAgBC,GAEnD,OAAOhF,OAAO+F,GAAc,IA7J8C,KA+JtEgJ,YAAc,SAAChK,EAAwBC,GAC3C,IAAMe,EAAa,EAAKC,WAAWjB,EAAgBC,GAEnD,OAAOhF,OAAO+F,EAAa,IAlK+C,KAoKtEiJ,sBAAwB,SAACjK,EAAwBC,GACrD,IAAMe,EAAa,EAAKC,WAAWjB,EAAgBC,GAEnD,OAAOhF,OAAO+F,GAAc,IAvK8C,KA0KtEC,WAAa,SAACjB,EAAwBC,GAC1C,IAAMsB,EAAU,EAAK1C,cAAc6G,WAAW1F,GACxCwB,EAAW,EAAK3C,cAAc6G,WAAWzF,GAE/C,OAAOsB,EAAQE,cAAcD,IA7K7B,IAAMhF,EAAS,IAAIgM,YAAY0B,OAAO,CAAEC,QXZpB,IWY2CC,QXZ3C,MWcpB9Q,KAAKmM,cAAgB,IAAIlJ,GAAc,IAAI8N,WAAW7N,EAAO0L,SAC7D5O,KAAKuF,cAAgB,IAAIX,GAAc5E,KAAKmM,eAC5CnM,KAAKsP,gBAAkB,CACnB5G,IAAK,CACDxF,UAEJ8N,UAAW,CACPzS,MAAOyB,KAAKzB,MACZuH,MAAO9F,KAAK8F,MACZC,QAAS/F,KAAK+F,QACdE,UAAWjG,KAAKiG,UAChBC,IAAKlG,KAAKkG,IACVE,IAAKpG,KAAKoG,IACVE,KAAMtG,KAAKsG,KACXC,UAAWvG,KAAKuG,UAChB7H,OAAQsB,KAAKtB,OACbmI,IAAK7G,KAAK6G,IACVoJ,KAAMjQ,KAAKiQ,KACXC,YAAalQ,KAAKkQ,YAClBC,aAAcnQ,KAAKmQ,aACnB/H,YAAapI,KAAKoI,YAClBC,YAAarI,KAAKqI,YAClB+H,kBAAmBpQ,KAAKoQ,kBACxBC,UAAWrQ,KAAKqQ,UAChBC,WAAYtQ,KAAKsQ,WACjBC,eAAgBvQ,KAAKuQ,eACrBC,SAAUxQ,KAAKwQ,SACfC,mBAAoBzQ,KAAKyQ,mBACzBC,YAAa1Q,KAAK0Q,YAClBC,sBAAuB3Q,KAAK2Q,yBC3C/BM,GAGT,WAAYC,EAAwB1U,GAA+B,IAAD,gCAF1DoM,aAE0D,OASlEC,IATkE,sBAS5D,sBAAA7C,EAAA,+EACK,EAAK4C,QAAQC,OADlB,2CARF,IAAMsI,EAAaC,KAASC,WAAWH,GACvCE,KAASE,iBAAiB,GAC1BH,EAAWI,UAAU,CAAC,aACtB,IAAMlC,EAAS8B,EAAWK,aAE1BxR,KAAK4I,QAAU,IAAItD,GAAQ+J,EAAQ7S,ICR9BiV,GAA0C,SAAC5Z,GAAW,IACvD6Z,EAAQ7Z,EAAR6Z,IADsD,EAEFzT,IAFE,mBAEvDzB,EAFuD,KAExCH,EAFwC,KAE9BC,EAF8B,KAEnBC,EAFmB,OCFtC,SAACC,EAA4BkV,GAAsC,IAAD,EACxDpc,oBAAkB,GADsC,mBACnFoW,EADmF,KACxEC,EADwE,KAGpFgG,EAAYvX,mBAAQ,kBAAM,IAAI6W,GAAcF,WAAWa,KAAKF,GAAMlV,KAAgB,CACpFkV,EACAlV,IA4BJ,MAAO,CAzBKrG,sBAAW,sBAAC,4BAAA6P,EAAA,6DACpBxJ,EAAc6B,QACdsN,GAAa,GAFO,kBAIKgG,EAAU9I,MAJf,OAIVgD,EAJU,OAKhBrP,EAAcoC,UAAd,kCAAmDiN,IALnC,gDAOZ,gBAAenJ,GACflG,EAAc+B,MAAd,2EACwE,KAAItB,MAD5E,yBACkG,KAAI0F,UAE/F,gBAAeC,GACtBpG,EAAc+B,MAAd,kFAIAzI,QAAQD,MAAR,MACA2G,EAAcoC,UAAd,wCACqC,KAAIzB,QADzC,6CAjBY,QAsBpBwO,GAAa,GAtBO,yDAuBrB,CAACgG,EAAWnV,IAEFkP,GD3BYmG,CAAarV,EAAekV,GAJS,mBAIvD7I,EAJuD,KAIlD6C,EAJkD,KAM9D,OACI,yBAAKtU,UAAU,uBACX,kBAAC,EAAD,CACIoF,cAAeA,EACfH,SAAUA,EACVC,UAAWA,EACXC,cAAeA,IAEnB,kBAAC,GAAD,CAAWwP,SAAUL,EAAW/T,QAASkR,MAU/CmD,GAAsC,SAACnU,GACzC,OACI,4BAAQT,UAAU,aAAa2U,SAAUlU,EAAMkU,SAAUpU,QAASE,EAAMF,SAAxE,gBExBKma,GAAb,4MACa1E,MAAQ,CACbvX,MAAO,MAFf,iEASsBA,EAAckc,GAC5Bjc,QAAQD,MAAMA,EAAOkc,KAV7B,+BAcQ,OAAyB,OAArB/R,KAAKoN,MAAMvX,MACJ,oCAAGmK,KAAKnI,MAAMma,UAGlB,oCAAGhS,KAAKnI,MAAMuF,aAlB7B,gDAKoCvH,GAC5B,MAAO,CAAEA,aANjB,GAAmCoc,IAAMC,WCF5BC,I,OAAsC,SAACta,GAChD,OAAkB,OAAdA,EAAM6Z,IACC,kBAAC,GAAD,MAGH,kBAAC,GAAD,CAAeM,SAAU,kBAAC,GAAD,OACrB,kBAAC,GAAD,CAAaN,IAAK7Z,EAAM6Z,SAMlCU,GAA2B,WAC7B,OACI,yBAAKhb,UAAU,uBACX,wEACA,mEClBCib,GAA0B,SAACxa,GACpC,OAAO,oCAAGA,EAAMuF,WCGPkV,I,OAA4B,SAACza,GAAW,IAAD,EACNvC,mBAAS,GADH,mBACzCid,EADyC,KAC1BC,EAD0B,KAG1CC,EAAQR,IAAMS,SAASnb,IAAIM,EAAMuF,UAAU,SAACuV,GAC9C,IAAKA,EACD,MAAM,IAAI3U,MAAM,yCAGpB,IAAM4U,EAAWD,EACjB,IAAKC,EAAS/a,MACV,MAAM,IAAImG,MAAM,yCAGpB,IAAMnG,EAAQ+a,EAAS/a,MACvB,IAAKA,EAAMb,KACP,MAAM,IAAIgH,MAAM,yCAGpB,OAAOnG,EAAMb,QAGjB,GjBnBiB,SAAIZ,GACrB,OAAc,OAAVA,QAA4B0F,IAAV1F,EiBkBlByc,CAAMJ,GACN,MAAM,IAAIzU,MAAM,yCAGpB,IACM8U,EADYb,IAAMS,SAASK,QAAQlb,EAAMuF,UAClBmV,GAE7B,OACI,yBAAKnb,UAAU,kBACX,kBAAC,GAAD,CACIqb,MAAOA,EACPF,cAAeA,EACfC,iBAAkBA,IAErBM,KAUPE,GAA0C,SAAC,GAAgD,IAA9CP,EAA6C,EAA7CA,MAAOF,EAAsC,EAAtCA,cAAeC,EAAuB,EAAvBA,iBACrE,OACI,yBAAKpb,UAAU,gBACVqb,EAAMlb,KAAI,SAACP,EAAMiG,GAAP,OACP,kBAAC,GAAD,CACI7H,IAAK4B,EACLA,KAAMA,EACNiG,MAAOA,EACPsV,cAAeA,EACfC,iBAAkBA,SAchCS,GAAsC,SAAC,GAAsD,IC7EpEnb,EAA2BC,ED6EXf,EAAmD,EAAnDA,KAAMiG,EAA6C,EAA7CA,MAAOsV,EAAsC,EAAtCA,cAAeC,EAAuB,EAAvBA,iBACjEU,EAAgBjW,IAAUsV,EAAgB,WAAa,GAEvDY,EAAYhd,uBAAY,WAC1Bqc,EAAiBvV,KAClB,CAACA,EAAOuV,IAGX,OCrF2B1a,EDmFZ,CAAC,GAAKmF,GCnFiClF,EDmFzBob,EClF7Blb,qBAAU,WACN,IAAMC,EAAa,SAACC,GACZL,EAAgBM,SAASD,EAAEE,UAAYF,EAAEG,SAAWH,EAAEib,SACtDrb,IACAI,EAAEI,mBAMV,OAFAC,SAASC,iBAAiB,UAAWP,GAE9B,WACHM,SAASE,oBAAoB,UAAWR,MAE7C,CAACH,EAASD,IDwET,4BAAQ1C,IAAK4B,EAAMI,UAAW8b,EAAevb,QAASwb,GACjDnc,IEjFAqc,I,OAAwC,SAAC,GAAa,IACzDC,ECNoB,SAAC5B,GAM3B,OALqBtX,mBAAQ,WAEzB,OADmBgX,KAASC,WAAWK,GACrB6B,aACnB,CAAC7B,IDEQ8B,CADkD,EAAV9B,KAEpD,OACI,yBAAKta,UAAU,iBACX,6BAAMkc,MEgCLG,GAA6C,SAAC,GAAiB,IAAfC,EAAc,EAAdA,QAAc,EAC/Cve,EAA6B,cAAeuB,GADG,mBAChEO,EADgE,KAC1DJ,EAD0D,KAGjE8c,EC5CsB,SAAC1c,EAAcyc,GAqB3C,OApBqCtZ,mBAAQ,WACzC,IACI,IAAMyR,EAAS6H,EAAQzc,GAEvB,OADAnB,QAAQC,IAAI8V,GACLA,EACT,MAAO+H,GAGL,OAFA9d,QAAQC,IAAI,6CACZD,QAAQD,MAAM+d,GACP,CACHhe,MAAO,KACPie,UAAW,KACXC,OAAQ,KACRC,UAAW,KACX7X,MAAO,KACP8X,KAAM,KACNtC,IAAK,SAGd,CAACgC,EAASzc,IDyBSgd,CAAiBhd,EAAMyc,GAE7C,OACI,yBAAKtc,UAAU,sBACX,kBAAC,GAAD,KACI,kBAAC,GAAD,CAAKJ,KAAK,UACN,kBAAC,EAAD,CAAYgB,YAAanB,KAE7B,kBAAC,GAAD,CAAKG,KAAK,OACN,kBAAC,EAAD,CAAW2C,IAAKga,EAAcG,UAElC,kBAAC,GAAD,CAAK9c,KAAK,QACN,kBAAC,EAAD,CAAY6E,UAAW8X,EAAcI,aAEzC,kBAAC,GAAD,CAAK/c,KAAK,SACN,kBAAC,EAAD,CAAakF,MAAOyX,EAAczX,SAEtC,kBAAC,GAAD,CAAKlF,KAAK,QACN,kBAAC,GAAD,CAAY0a,IAAKiC,EAAcjC,OAEnC,kBAAC,GAAD,CAAK1a,KAAK,eACN,kBAAC,GAAD,CAAakF,MAAOyX,EAAczX,SAEtC,kBAAC,GAAD,CAAKlF,KAAK,aACN,kBAAC,GAAD,CAAW0a,IAAKiC,EAAcjC,QAGtC,uBAAGta,UAAU,wBAAb,+BACgC,gDADhC,MACiE,IAC7D,+CEvEV8c,I,OAAgBjC,IAAMkC,KAAN,sBAClB,8BAAAnO,EAAA,sEACuB,8BADvB,cACUgO,EADV,OAEU9B,EAAsB,kBAAM,kBAAC,GAAD,CAAmBwB,QAASM,EAAKN,WAFvE,kBAIW,CAAEU,QAASlC,IAJtB,6CAQSmC,GAAqB,WAC9B,OACI,yBAAKjd,UAAU,sBACX,kBAAC,WAAD,CAAU4a,SAAU,4CAChB,kBAACkC,GAAD,SCfHI,I,OAAmB,WAC5B,OACI,4BAAQld,UAAU,oBACd,wBAAIA,UAAU,SAAd,UACA,0BAAMA,UAAU,eAAhB,yDCMGmd,GATO,WAClB,OACI,yBAAKnd,UAAU,OACX,kBAAC,GAAD,MACA,kBAAC,GAAD,Q,OCHZod,IAASC,OAAO,kBAAC,GAAD,MAASjc,SAASkc,eAAe,W","file":"static/js/main.cff87c0e.chunk.js","sourcesContent":["import { useState, useCallback } from 'react';\n\nexport const useLocalStorageState = <T>(\n    key: string,\n    initialValue: T\n): [T, React.Dispatch<React.SetStateAction<T>>] => {\n    // Pass initial state function to useState so logic is only executed once\n    const [storedValue, setStoredValue] = useState<T>(() => {\n        try {\n            const item: string | null = window.localStorage.getItem(key);\n            // Parse stored json or if none return initialValue\n            return item ? JSON.parse(item) : initialValue;\n        } catch (error) {\n            // If error also return initialValue\n            console.log(error);\n            return initialValue;\n        }\n    });\n\n    // Return a wrapped version of useState's setter function that persists the new value to localStorage.\n    const setValue: React.Dispatch<React.SetStateAction<T>> = useCallback(\n        (value): void => {\n            try {\n                // Allow value to be a function so we have same API as useState\n                const valueToStore: T = value instanceof Function ? value(storedValue) : value;\n\n                setStoredValue(valueToStore);\n\n                window.localStorage.setItem(key, JSON.stringify(valueToStore));\n            } catch (error) {\n                // We'll suppose you have localstorage, if not well... Just log for now.\n                console.warn(error);\n            }\n        },\n        [key, storedValue]\n    );\n\n    return [storedValue, setValue];\n};\n","export const baseCode = `\n/* Enter your tiger code */\n(\n    print(\"Hello world!\");\n    0\n)\n`;\n","import factorial from './examples/factorial.tig';\nimport stringConcat from './examples/stringConcat.tig';\nimport basicArray from './examples/basicArray.tig';\nimport fizzBuzz from './examples/fizzbuzz.tig';\nimport bubbleSort from './examples/bubbleSort.tig';\nimport queens from './examples/queens.tig';\nimport { useLocalStorageState } from '../../hooks/useLocalStorageState';\n\ninterface ExamplesByName {\n    [name: string]: string;\n}\n\nconst EXAMPLES: ExamplesByName = {\n    'factorial.tig': factorial,\n    'stringConcat.tig': stringConcat,\n    'basicArray.tig': basicArray,\n    'fizzBuzz.tig': fizzBuzz,\n    'bubbleSort.tig': bubbleSort,\n    'queens.tig': queens\n};\n\nconst EXAMPLES_KEY = 'hector_examples';\n\ntype SaveExampleAction = (name: string, code: string) => void;\ntype DeleteExampleAction = (name: string, code: string) => void;\n\nexport const useExamples = (): [ExamplesByName, SaveExampleAction, DeleteExampleAction] => {\n    const [examples, setExamples] = useLocalStorageState<ExamplesByName>(EXAMPLES_KEY, EXAMPLES);\n\n    const saveExample = (name: string, code: string): void => {\n        setExamples({\n            ...examples,\n            [name]: code,\n        });\n    };\n\n    const deleteExample = (name: string): void => {\n        const { [name]: omitted, ...newExamples } = examples;\n\n        setExamples(newExamples);\n    };\n\n    return [examples, saveExample, deleteExample];\n};\n","export default \"let\\n    function fact (n : int) : int =\\n        if  n = 0\\n            then 1\\n            else n * fact (n - 1)\\nin\\n    fact (5)\\nend\\n\";","export default \"let\\n    var mila := \\\"mila\\\"\\n    var nesa := \\\"nesa\\\"\\n    var milanesa := concat(mila, nesa)\\nin\\n    print(milanesa); 0\\nend\";","export default \"let\\n    type intarray = array of int\\n    var arr1: intarray := intarray [10] of 5\\nin\\n    arr1[5] := 42;\\n    arr1[5]\\nend\\n\";","export default \"let\\n    function mod(i: int, c: int) : int =\\n        i - (i / c) * c = 0\\n\\n    function printdigit (i : int) = (\\n        print(chr(ord(\\\"0\\\") + i))\\n    )\\n\\n    function printint (i : int) = (\\n        if i < 10 then (\\n            printdigit(i)\\n        ) else (\\n            printint(i / 10);\\n            printdigit(i - (i / 10) * 10)\\n        )\\n    )\\n\\n    function FizzBuzz() = (\\n        for i := 1 to 100 do (\\n            if mod(i, 3) & mod(i, 5) then\\n                print(\\\"FizzBuzz\\\\n\\\")\\n            else if mod(i, 3) then\\n                print(\\\"Fizz\\\\n\\\")\\n            else if mod(i, 5) then\\n                print(\\\"Buzz\\\\n\\\")\\n            else\\n                (printint(i); print(\\\"\\\\n\\\"))\\n        )\\n    )\\nin\\n    (FizzBuzz(); 0)\\nend\";","export default \"let\\n    function writedigit(i : int): string = (\\n        chr(ord(\\\"0\\\") + i)\\n    )\\n\\n    function writeint(i : int): string = (\\n        if i < 10 then (\\n            writedigit(i)\\n        ) else (\\n            concat(\\n                writeint(i / 10),\\n                writedigit(i - (i / 10) * 10)\\n            )\\n        )\\n    )\\n\\n    function printint(i: int) = (\\n        print(writeint(i))\\n    )\\n\\n    function readdigit(s: string): int = (\\n        ord(s) - ord(\\\"0\\\")\\n    )\\n\\n    function readint(s: string): int = (\\n        let\\n            var strSize := size(s)\\n        in\\n            if strSize = 1 then (\\n                readdigit(s)\\n            ) else (\\n                readint(substring(s, 0, strSize - 1)) * 10 +\\n                readdigit(substring(s, strSize - 1, strSize))\\n            )\\n        end\\n    )\\n\\n    var arrSize := (\\n        print(\\\"Enter array size:\\\");\\n        readint(getstring())\\n    )\\n\\n    type intarray = array of int\\n    var arr: intarray := intarray [arrSize] of 0\\n\\n    function readArray() = (\\n        (for r := 0 to (arrSize - 1) do (\\n            print(concat(\\\"enter element \\\", writeint(r)));\\n            arr[r] := readint(getstring())\\n        ))\\n    )\\n\\n    function printArray() = (\\n        print(\\\"[\\\");\\n        (for i := 0 to (arrSize - 1) do (\\n            printint(arr[i]);\\n            if i <> (arrSize - 1) then print(\\\", \\\")\\n        ));\\n        print(\\\"]\\\")\\n    )\\n\\n    function swap(pos1: int, pos2: int) = (\\n        let\\n            var temp := arr[pos1]\\n        in\\n            arr[pos1] := arr[pos2];\\n            arr[pos2] := temp\\n        end\\n    )\\n\\n    function sortArray() = (\\n        (for i := 0 to (arrSize - 1) do (\\n            (for j := 0 to (arrSize - 2 - i) do (\\n                if arr[j] > arr[j + 1] then (\\n                    swap(j, j + 1)\\n                )\\n            ))\\n        ))\\n    )\\nin\\n    readArray();\\n\\n    print(\\\"\\\\n\\\");\\n    print(\\\"Original array:\\\\n\\\");\\n    printArray();\\n    print(\\\"\\\\n\\\");\\n\\n\\n    print(\\\"\\\\n\\\");\\n    print(\\\"Sorted array:\\\\n\\\");\\n    sortArray();\\n    printArray();\\n    print(\\\"\\\\n\\\");\\n\\n    0\\nend\";","export default \"/* A program to solve the 8-queens problem */\\n\\nlet\\n    var N := 8\\n\\n    type intArray = array of int\\n\\n    var row := intArray [ N ] of 0\\n    var col := intArray [ N ] of 0\\n    var diag1 := intArray [N+N-1] of 0\\n    var diag2 := intArray [N+N-1] of 0\\n\\n    function printboard () =\\n       (for i := 0 to N-1\\n\\t do (for j := 0 to N-1\\n\\t      do print (if col[i]=j then \\\" O\\\" else \\\" .\\\");\\n\\t     print (\\\"\\\\n\\\"));\\n         print (\\\"\\\\n\\\"))\\n\\n    function try (c : int) =\\n( /*  for i := 0 to c do print (\\\".\\\"); print (\\\"\\\\n\\\"); flush ();*/\\n     if c=N\\n     then printboard ()\\n     else (for r := 0 to N-1\\n\\t   do if row[r]=0 & diag1[r+c]=0 & diag2[r+7-c]=0\\n\\t           then (row[r] :=1; diag1[r+c] :=1; diag2[r+7-c] :=1;\\n\\t\\t         col[c] :=r;\\n\\t                 try (c+1);\\n\\t\\t\\t row[r] :=0; diag1[r+c] :=0; diag2[r+7-c] :=0))\\n\\n)\\n in try (0); 0\\nend\\n\";","import React from 'react';\nimport { useExamples } from './useExamples';\n\ninterface ExamplesProps {\n    setCode: React.Dispatch<React.SetStateAction<string>>;\n}\n\nexport const Examples: React.FC<ExamplesProps> = ({ setCode }) => {\n    const [examples] = useExamples();\n\n    return (\n        <div className=\"examples-list-container\">\n            <h3>Examples</h3>\n            <ul className=\"examples-list\">\n                {Object.entries(examples).map(([fileName, content]) => {\n                    return (\n                        <ExampleItem\n                            key={fileName}\n                            fileName={fileName}\n                            content={content}\n                            setCode={setCode}\n                        />\n                    );\n                })}\n            </ul>\n        </div>\n    );\n};\n\ninterface ExampleItemProps {\n    fileName: string;\n    content: string;\n    setCode: React.Dispatch<React.SetStateAction<string>>;\n}\nconst ExampleItem: React.FC<ExampleItemProps> = ({ fileName, content, setCode }) => {\n    const onClick = () => {\n        setCode(content);\n    };\n\n    return (\n        <li>\n            <button onClick={onClick}>{fileName}</button>\n        </li>\n    );\n};\n","import React, { CSSProperties } from 'react';\nimport AceEditor, { IEditorProps } from 'react-ace';\nimport { useLocalStorageState } from '../../hooks/useLocalStorageState';\nimport { useCtrlKeys } from '../../hooks/useCtrlKeys';\nimport { baseCode } from '../../utils/baseCode';\nimport { Examples } from './Examples';\nimport 'ace-builds/src-noconflict/theme-monokai';\nimport 'ace-builds/src-noconflict/mode-golang';\nimport './CodeEditor.scss';\n\ninterface CodeEditorProps {\n    compileCode: (code: string) => void;\n}\n\nexport const CodeEditor: React.FC<CodeEditorProps> = (props) => {\n    const { compileCode } = props;\n\n    const [code, setCode] = useLocalStorageState<string>('hector-code', baseCode);\n\n    useCtrlKeys([13, 83], () => compileCode(code));\n\n    const editorStyles: CSSProperties = {\n        height: '600px',\n        fontSize: '14px',\n        width: '85%',\n    };\n\n    return (\n        <div className=\"code-editor-container\">\n            <Examples setCode={setCode} />\n            <AceEditor\n                mode=\"golang\"\n                theme=\"monokai\"\n                onChange={(newCode) => setCode(newCode)}\n                value={code}\n                name=\"code-editor\"\n                editorProps={{ $blockScrolling: true }}\n                style={editorStyles}\n                showPrintMargin={false}\n                onLoad={(editor: IEditorProps) => editor.focus()}\n                onBlur={() => compileCode(code)}\n            />\n        </div>\n    );\n};\n","import { useEffect } from 'react';\n\nexport const useCtrlKeys = (compileKeyCodes: number[], handler: () => void): void => {\n    useEffect(() => {\n        const keyHandler = (e: KeyboardEvent): void => {\n            if (compileKeyCodes.includes(e.keyCode) && e.ctrlKey) {\n                handler();\n                e.preventDefault();\n            }\n        };\n\n        document.addEventListener('keydown', keyHandler);\n\n        return () => {\n            document.removeEventListener('keydown', keyHandler);\n        };\n    }, [handler, compileKeyCodes]);\n};\n","import React, { useMemo, useState } from 'react';\nimport ReactJson from 'react-json-view';\nimport { cleanAst, CleanOptions } from '../../utils/cleanAst';\nimport { EscapeResult } from '../Compiler/CompilerInterface';\nimport './ASTViewer.scss';\n\ninterface ASTViewerProps {\n    ast: EscapeResult;\n}\n\nexport const ASTViewer: React.FC<ASTViewerProps> = (props) => {\n    const { ast } = props;\n\n    if (ast === null) {\n        return (\n            <div>\n                <h3>No AST to show!</h3>\n                <p>Did you compile the code?</p>\n                <p>If so, check the WASM results to see if there were any errors</p>\n            </div>\n        );\n    } else {\n        return <OkASTViewer ast={ast} />;\n    }\n};\n\nconst OkASTViewer: React.FC<ASTViewerProps> = (props) => {\n    const { ast } = props;\n\n    const [options, setOptions] = useState<CleanOptions>({\n        cleanType: true,\n        cleanPosition: true,\n        cleanNode: true,\n        cleanEscape: true,\n    });\n\n    const prettyAst = useMemo(() => cleanAst(ast, options), [ast, options]);\n\n    // An AST is valid if it has at least one key\n    const isValidAst = Object.keys(prettyAst).length > 0;\n\n    return (\n        <div className=\"ast-viewer\">\n            <ReactJson\n                src={prettyAst}\n                theme=\"monokai\"\n                enableClipboard={false}\n                displayObjectSize={false}\n                displayDataTypes={false}\n            />\n            {isValidAst && <CleanControls options={options} setOptions={setOptions} />}\n        </div>\n    );\n};\n\ninterface CleanControlsProps {\n    options: CleanOptions;\n    setOptions: React.Dispatch<React.SetStateAction<CleanOptions>>;\n}\n\nconst CleanControls: React.FC<CleanControlsProps> = ({ options, setOptions }) => {\n    const [collapsed, setCollapsed] = useState<boolean>(true);\n    const toggleCollapse = () => setCollapsed(!collapsed);\n\n    const optionsClassName = `options-container ${collapsed ? 'collapsed' : 'expanded'}`;\n\n    return (\n        <div className=\"clean-controls-container\">\n            <button className=\"collapse-button\" onClick={toggleCollapse}>\n                {collapsed ? 'Options' : 'Collapse'}\n            </button>\n            <div className={optionsClassName}>\n                {Object.entries(options).map(([option, value]) => {\n                    const onChange = () => setOptions({ ...options, [option]: !value });\n                    return (\n                        <div className=\"option-checkbox\" key={option}>\n                            <input\n                                id={option}\n                                type=\"checkbox\"\n                                checked={value}\n                                onChange={onChange}\n                            />\n                            <label htmlFor={option}>{option}</label>\n                        </div>\n                    );\n                })}\n            </div>\n        </div>\n    );\n};\n","export interface CleanOptions {\n    cleanType?: boolean;\n    cleanPosition?: boolean;\n    cleanNode?: boolean;\n    cleanEscape?: boolean;\n}\n\nexport const cleanAst = (ast: any, options: CleanOptions = {}): any => {\n    const {\n        cleanType = true,\n        cleanPosition = true,\n        cleanNode = true,\n        cleanEscape = true,\n    } = options;\n\n    // If it's a json\n    if (typeof ast === 'object' && !Array.isArray(ast) && ast !== null) {\n        const prettyAst: any = {};\n\n        Object.keys(ast).forEach((k) => {\n            // Clean nodes if necessary\n            if (k === 'node' && cleanNode) {\n                const nodeName = Object.keys(ast['node'])[0];\n                prettyAst[nodeName] = cleanAst(ast['node'][nodeName], options);\n                return;\n            }\n\n            // Clean position if necessary\n            if (k === 'pos' && cleanPosition) {\n                return;\n            }\n\n            // Clean type if necessary\n            if (k === 'typ' && cleanType) {\n                return;\n            }\n\n            // Clean escapes if necessary\n            if (k === 'escape' && cleanEscape) {\n                return;\n            }\n\n            prettyAst[k] = cleanAst(ast[k], options);\n        });\n\n        return prettyAst;\n    }\n\n    // If it's an array\n    if (typeof ast === 'object' && Array.isArray(ast)) {\n        return ast.map((elem) => cleanAst(elem, options));\n    }\n\n    // If it's not an object/array don't modify it.\n    return ast;\n};\n","import React from 'react';\nimport ReactJson from 'react-json-view';\nimport { TranslateResult } from '../Compiler/CompilerInterface';\n\ninterface TREEViewerProps {\n    fragments: TranslateResult;\n}\n\nexport const TREEViewer: React.FC<TREEViewerProps> = (props) => {\n    const { fragments } = props;\n\n    if (fragments === null) {\n        return (\n            <div>\n                <h3>No fragments to show!</h3>\n                <p>Did you compile the code?</p>\n                <p>If so, check the WASM results to see if there were any errors</p>\n            </div>\n        );\n    } else if (fragments.Err !== undefined) {\n        return (\n            <div>\n                <h3>No fragments to show!</h3>\n                <p>check the WASM results, it seems there was an error translating</p>\n            </div>\n        );\n    } else {\n        return <OkTREEViewer fragments={fragments} />;\n    }\n};\n\nexport const OkTREEViewer: React.FC<TREEViewerProps> = (props) => {\n    // We're sure this is NOT null\n    const { fragments } = props;\n\n    return (\n        <div className=\"tree-viewer\">\n            <ReactJson\n                src={fragments as any}\n                theme=\"monokai\"\n                enableClipboard={false}\n                displayObjectSize={false}\n                displayDataTypes={false}\n            />\n        </div>\n    );\n};\n","import React from 'react';\nimport ReactJson from 'react-json-view';\nimport { CanonResult } from '../Compiler/CompilerInterface';\n\ninterface CanonViewerProps {\n    canon: CanonResult | null;\n}\n\nexport const CanonViewer: React.FC<CanonViewerProps> = (props) => {\n    const { canon } = props;\n\n    if (canon === null) {\n        return (\n            <div>\n                <h3>No fragments to show!</h3>\n                <p>Did you compile the code?</p>\n                <p>If so, check the WASM results to see if there were any errors</p>\n            </div>\n        );\n    } else {\n        return <OkCanonViewer canon={canon} />;\n    }\n};\n\nexport const OkCanonViewer: React.FC<CanonViewerProps> = (props) => {\n    // We're sure this is NOT null\n    const { canon } = props;\n\n    return (\n        <div className=\"canon-viewer\">\n            <ReactJson\n                src={canon as any}\n                theme=\"monokai\"\n                enableClipboard={false}\n                displayObjectSize={false}\n                displayDataTypes={false}\n            />\n        </div>\n    );\n};\n","import React, { useState, useRef, useEffect } from 'react';\nimport { UserConsole } from '../../hooks/useConsole';\n\nimport './CustomConsole.scss';\n\nconst prompt = '>';\n\ninterface CustomConsoleProps {\n    customConsole: UserConsole;\n    messages: string[];\n    isReading: boolean;\n    isReadingChar: boolean;\n}\n\nexport const CustomConsole: React.FC<CustomConsoleProps> = (props) => {\n    const { messages, isReading, isReadingChar, customConsole } = props;\n\n    const consoleRef = useRef<HTMLDivElement | null>(null);\n    useEffect(() => {\n        const element = consoleRef.current;\n        if (element !== null) {\n            element.scrollTop = element.scrollHeight;\n        }\n    });\n\n    return (\n        <div className=\"custom-console\" ref={consoleRef}>\n            {messages.map((msg: string, index: number) => {\n                return <MessageWithPrompt key={index}>{msg}</MessageWithPrompt>;\n            })}\n            {isReading && <ConsoleInput customConsole={customConsole} />}\n            {isReadingChar && <ConsoleCharInput customConsole={customConsole} />}\n        </div>\n    );\n};\n\ninterface MessageWithPromptProps {\n    children: string;\n}\n\nconst MessageWithPrompt: React.FC<MessageWithPromptProps> = (props) => {\n    const message = props.children;\n\n    return (\n        <div className=\"message-with-prompt\">\n            <span className=\"prompt\">{prompt}</span>\n            <pre className=\"message\">{message}</pre>\n        </div>\n    );\n};\n\ninterface ConsoleInputProps {\n    customConsole: UserConsole;\n}\n\nconst ConsoleInput: React.FC<ConsoleInputProps> = (props) => {\n    const [message, setMessage] = useState('');\n\n    const onChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        const { value } = event.target;\n\n        setMessage(value);\n    };\n\n    const onKeyPress = (event: React.KeyboardEvent<HTMLInputElement>) => {\n        const { key } = event;\n\n        if (key === 'Enter') {\n            props.customConsole.resolveRead(message);\n        }\n    };\n\n    return (\n        <div className=\"message-with-prompt\">\n            <span className=\"prompt\">{prompt}</span>\n            <input\n                className=\"input\"\n                autoFocus={true}\n                onChange={onChange}\n                value={message}\n                onKeyPress={onKeyPress}\n                spellCheck={false}\n            />\n        </div>\n    );\n};\n\nconst ConsoleCharInput: React.FC<ConsoleInputProps> = (props) => {\n    const [message, setMessage] = useState<string>('');\n    const onChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        const { value } = event.target;\n        setMessage(value);\n\n        if (value.length >= 1) {\n            props.customConsole.resolveRead(value[0]);\n        }\n    };\n\n    return (\n        <div className=\"message-with-prompt\">\n            <span className=\"prompt\">{prompt}</span>\n            <input\n                className=\"input\"\n                autoFocus={true}\n                onChange={onChange}\n                value={message}\n                spellCheck={false}\n            />\n        </div>\n    );\n};\n","import { CustomConsole } from '../utils/console';\nimport { useState, useMemo } from 'react';\n\nexport interface UserConsole extends CustomConsole {\n    clear: () => void;\n    resolveRead: (str: string) => void;\n    printLine: (str: string) => void;\n}\n\nconst illegalResolve = (str: string): void => {\n    throw new Error('Cannot resolve a string if not reading!');\n};\n\nexport const useConsole = (): [UserConsole, string[], boolean, boolean] => {\n    const [messages, setMessages] = useState<string[]>(['']);\n\n    const [isReading, setIsReading] = useState<boolean>(false);\n\n    const [isReadingChar, setIsReadingChar] = useState<boolean>(false);\n\n    const hookConsole = useMemo(() => {\n        class HookConsole implements UserConsole {\n            resolveRead: (str: string) => void = illegalResolve;\n\n            clear = () => {\n                setMessages((_oldMessages) => ['']);\n            };\n\n            print = (str: string) => {\n                setMessages((oldMessages) => {\n                    const newMessages = [...oldMessages];\n\n                    newMessages[newMessages.length - 1] = newMessages[\n                        newMessages.length - 1\n                    ].concat(str.replace(/\\\\n/g, '\\n'));\n\n                    return newMessages;\n                });\n            };\n\n            printLine = (str: string) => {\n                setMessages((oldMessages) => [...oldMessages, str]);\n            };\n\n            read = () => {\n                return new Promise<string>((resolve) => {\n                    setIsReading(true);\n\n                    this.resolveRead = (str: string) => {\n                        setMessages((oldMessages) => [...oldMessages, str, '']);\n                        setIsReading(false);\n\n                        // Send this value over to the console consumer\n                        resolve(str);\n                    };\n                });\n            };\n\n            readChar = () => {\n                return new Promise<string>((resolve) => {\n                    setIsReadingChar(true);\n\n                    this.resolveRead = (str: string) => {\n                        const char = str[0];\n                        setMessages((oldMessages) => [...oldMessages, char, '']);\n                        setIsReadingChar(false);\n\n                        // Send this value over to the console consumer\n                        resolve(char);\n                    };\n                });\n            };\n        }\n\n        return new HookConsole();\n    }, []);\n\n    return [hookConsole, messages, isReading, isReadingChar];\n};\n","export class NotImplementedError extends Error {\n    constructor() {\n        super('Not implemented!');\n    }\n}\n\nexport class UnexpectedUndefinedError extends Error {\n    constructor(msg?: string) {\n        super(msg ?? 'Unexpected undefined value!');\n    }\n}\n\nexport class UnreachableError extends Error {\n    constructor(msg?: string) {\n        super(msg ?? 'Unreachable branch');\n    }\n}\n\nexport const assertExists = <T>(value: T | undefined, msg?: string): T => {\n    if (value === undefined) {\n        throw new UnexpectedUndefinedError(msg);\n    } else {\n        return value;\n    }\n};\n\nexport const assertCondition = (condition: boolean, msg: string): void => {\n    if (!condition) {\n        throw new Error(msg);\n    }\n};\n\ninterface IncludeMapEntry<K, V> {\n    key: K;\n    value: V;\n}\n\nexport class IncludeMap<V> {\n    entries: IncludeMapEntry<string, V>[];\n\n    constructor() {\n        this.entries = [];\n    }\n\n    set = (key: string, value: V): IncludeMap<V> => {\n        const foundIndex = this.entries.findIndex((entry): boolean => entry.key.includes(key));\n\n        if (foundIndex >= 0) {\n            this.entries[foundIndex] = { key, value };\n        } else {\n            this.entries.push({ key, value });\n        }\n\n        return this;\n    };\n\n    get = (key: string): V | undefined => {\n        const maybeEntry = this.entries.find((entry): boolean => entry.key.includes(key));\n\n        if (maybeEntry === undefined) {\n            return undefined;\n        } else {\n            return maybeEntry.value;\n        }\n    };\n}\n","import { Exp } from './treeTypes';\n\nconst inLocalAccessExp = (name: string): Exp => ({\n    LOCAL: name,\n});\n\n// For now, all formals go in memory\nconst accessExpFromFormal = (formal: [string, boolean]): Exp => {\n    const [name] = formal;\n    return inLocalAccessExp(name);\n};\n\nexport const accessExpsFromFormals = (formals: [string, boolean][]): Exp[] => {\n    return formals.map(accessExpFromFormal);\n};\n","import { Stm, LabelStm, ExpStm, MoveStm, JumpStm, CjumpStm, SeqStm } from '../treeTypes';\n\nexport const isExpStm = (stm: Stm): stm is ExpStm => {\n    return 'EXP' in stm;\n};\n\nexport const isMoveStm = (stm: Stm): stm is MoveStm => {\n    return 'MOVE' in stm;\n};\n\nexport const isJumpStm = (stm: Stm): stm is JumpStm => {\n    return 'JUMP' in stm;\n};\n\nexport const isCjumpStm = (stm: Stm): stm is CjumpStm => {\n    return 'CJUMP' in stm;\n};\n\nexport const isSeqStm = (stm: Stm): stm is SeqStm => {\n    return 'SEQ' in stm;\n};\n\nexport const isLabelStm = (stm: Stm): stm is LabelStm => {\n    return 'LABEL' in stm;\n};\n","import { Label, Stm, BinOp, FragStm } from '../treeTypes';\nimport { isLabelStm } from './stmPatterns';\nimport { UnreachableError } from './utils';\n\nexport const findLabelIndex = (stms: Stm[], label: Label): number => {\n    const foundIndex = stms.findIndex((stm) => {\n        return isLabelStm(stm) && stm.LABEL === label;\n    });\n\n    if (foundIndex === -1) {\n        throw new Error(`Could not find label '${label}'!`);\n    }\n\n    return foundIndex;\n};\n\nexport const flatStms = (fragStms: FragStm[]): Stm[] => {\n    const stms: Stm[] = [];\n\n    fragStms.forEach((fragStm) => {\n        stms.push(...fragStm.stms);\n    });\n\n    return stms;\n};\n\nexport const evalBinop = (op: BinOp, leftVal: number, rightVal: number): number => {\n    switch (op) {\n        case 'PLUS':\n            return leftVal + rightVal;\n\n        case 'MINUS':\n            return leftVal - rightVal;\n\n        case 'MUL':\n            return leftVal * rightVal;\n\n        case 'DIV':\n            return Math.floor(leftVal / rightVal);\n\n        case 'AND':\n            return leftVal && rightVal;\n\n        case 'OR':\n            return leftVal || rightVal;\n\n        case 'LSHIFT':\n            return leftVal << rightVal;\n\n        case 'RSHIFT':\n            return leftVal >>> rightVal;\n\n        case 'ARSHIFT':\n            return leftVal >> rightVal;\n\n        case 'XOR':\n            return leftVal ^ rightVal;\n\n        case 'EQ':\n            return Number(leftVal === rightVal);\n\n        case 'NE':\n            return Number(leftVal !== rightVal);\n\n        case 'LT':\n            return Number(leftVal < rightVal);\n\n        case 'GT':\n            return Number(leftVal > rightVal);\n\n        case 'LE':\n            return Number(leftVal <= rightVal);\n\n        case 'GE':\n            return Number(leftVal >= rightVal);\n\n        case 'ULT':\n            // Not sure, our parser doesn't even generate this\n            return Number(leftVal < rightVal);\n\n        case 'ULE':\n            // Not sure, our parser doesn't even generate this\n            return Number(leftVal <= rightVal);\n\n        case 'UGT':\n            // Not sure, our parser doesn't even generate this\n            return Number(leftVal > rightVal);\n\n        case 'UGE':\n            // Not sure, our parser doesn't even generate this\n            return Number(leftVal >= rightVal);\n\n        default:\n            throw new UnreachableError();\n    }\n};\n","import { Frag, FunFrag, StringFrag } from '../treeTypes';\n\nexport const isFunFrag = (fragment: Frag): fragment is FunFrag => {\n    return 'Proc' in fragment;\n};\n\nexport const isStringFrag = (fragment: Frag): fragment is StringFrag => {\n    return 'ConstString' in fragment;\n};\n","import {\n    Exp,\n    MemExp,\n    LocalExp,\n    ConstExp,\n    NameExp,\n    BinopExp,\n    CallExp,\n    EseqExp,\n    GlobalExp,\n} from '../treeTypes';\n\nexport const isConstExp = (exp: Exp): exp is ConstExp => {\n    return 'CONST' in exp;\n};\n\nexport const isNameExp = (exp: Exp): exp is NameExp => {\n    return 'NAME' in exp;\n};\n\nexport const isLocalExp = (exp: Exp): exp is LocalExp => {\n    return 'LOCAL' in exp;\n};\n\nexport const isGlobalExp = (exp: Exp): exp is GlobalExp => {\n    return 'GLOBAL' in exp;\n};\n\nexport const isBinopExp = (exp: Exp): exp is BinopExp => {\n    return 'BINOP' in exp;\n};\n\nexport const isMemExp = (exp: Exp): exp is MemExp => {\n    return 'MEM' in exp;\n};\n\nexport const isCallExp = (exp: Exp): exp is CallExp => {\n    return 'CALL' in exp;\n};\n\nexport const isEseqExp = (exp: Exp): exp is EseqExp => {\n    return 'ESEQ' in exp;\n};\n","export class RuntimeExit {\n    constructor(readonly exitCode: number) {}\n}\n\nexport class OutOfBoundsException extends Error {\n    constructor(readonly index: number, readonly pointer: number) {\n        super(`Cannot access pointer ${pointer} at index ${index}`);\n    }\n}\n\nexport class NilPointerException extends Error {\n    constructor() {\n        super('Tried accessing nil pointer field');\n    }\n}\n","import { assertCondition } from '../interpreter/utils/utils';\nimport { OutOfBoundsException } from '../utils/runtimeUtils';\nimport { WORD_SZ } from '../utils/utils';\n\nfunction alignToNextWord(value: number): number {\n    return ((value + WORD_SZ - 1) / WORD_SZ) * WORD_SZ;\n}\n\nexport const MEMORY_PAGES = 256;\nexport const MEMORY_LENGTH = MEMORY_PAGES * 64 * 1024; // 16mb\n\nexport const HEAP_START = alignToNextWord(Math.floor(MEMORY_LENGTH / 3));\nexport const HEAP_END = HEAP_START * 2;\n\nexport const ASYNCIFY_DATA_START = HEAP_END;\nexport const ASYNCIFY_DATA_END = MEMORY_LENGTH;\n\nexport const BYTE_SIZE = 1;\n\nexport class MemoryManager {\n    private allocatedSizes: Map<number, number>;\n    private nextFreeIndex: number;\n\n    constructor(private memory: Uint8Array) {\n        this.nextFreeIndex = HEAP_START;\n        this.allocatedSizes = new Map();\n    }\n\n    alloc = (bytes: number): number => {\n        assertCondition(bytes > 0, 'Cannot alloc 0 bytes');\n        const pointer = this.nextFreeIndex;\n        this.nextFreeIndex += bytes;\n        assertCondition(this.nextFreeIndex < HEAP_END, 'Out of memory!');\n        this.allocatedSizes.set(pointer, bytes);\n        return pointer;\n    };\n\n    checkArrayIndex = (pointer: number, index: number): void => {\n        const byteCount = this.allocatedSizes.get(pointer);\n        if (byteCount === undefined) {\n            throw new Error('Not a valid array');\n        }\n        if (index * WORD_SZ >= byteCount || index < 0) {\n            throw new OutOfBoundsException(index, pointer);\n        }\n\n        return;\n    };\n\n    wordStore = (dir: number, value: number): void => {\n        wordAssertRange(dir);\n\n        this.memory[dir] = value & 255;\n        this.memory[dir + 1] = (value & (255 << 8)) >> 8;\n        this.memory[dir + 2] = (value & (255 << 16)) >> 16;\n        this.memory[dir + 3] = (value & (255 << 24)) >> 24;\n    };\n\n    wordGet = (dir: number): number => {\n        wordAssertRange(dir);\n\n        let value = this.memory[dir];\n        value += this.memory[dir + 1] << 8;\n        value += this.memory[dir + 2] << 16;\n        value += this.memory[dir + 3] << 24;\n\n        return value;\n    };\n\n    byteStore = (dir: number, value: number): void => {\n        byteAssertRange(dir);\n\n        this.memory[dir] = value;\n    };\n\n    byteGet = (dir: number): number => {\n        byteAssertRange(dir);\n\n        return this.memory[dir];\n    };\n\n    wordDebugSlice = (start: number, count: number): void => {\n        const values = [];\n        for (let i = 0; i < count; i++) {\n            const dir = start + i * WORD_SZ;\n            values.push(this.wordGet(dir));\n        }\n\n        console.log(values);\n    };\n\n    byteDebugSlice = (start: number, count: number): void => {\n        const values = [];\n        for (let i = 0; i < count; i++) {\n            const dir = start + i * BYTE_SIZE;\n            values.push(this.byteGet(dir));\n        }\n\n        console.log(values);\n        console.log(values.map((value) => String.fromCharCode(value)));\n    };\n}\n\nconst wordAssertRange = (dir: number): void => {\n    assertCondition(dir >= 0 && dir < HEAP_END - WORD_SZ, `Index ${dir} out of range`);\n};\n\nconst byteAssertRange = (dir: number): void => {\n    assertCondition(dir >= 0 && dir < HEAP_END - BYTE_SIZE, `Index ${dir} out of range`);\n};\n","import { ExpectedValues } from './expectedValues';\n\nexport const WORD_SZ = 4;\n\nexport const noop = () => {};\n\nexport const testExpectedValues = (returnValue: number, expectedValues: ExpectedValues): void => {\n    if (expectedValues.result !== null) {\n        expect(returnValue).toBe(expectedValues.result);\n    }\n};\n\nexport type nil = null | undefined;\nexport const isNil = <T>(value: T | nil): value is nil => {\n    if (value === null || value === undefined) {\n        return true;\n    }\n    return false;\n};\n","import { WORD_SZ } from '../../utils/utils';\nimport { HEAP_START } from '../../evaluator/memoryManager';\nimport { assertCondition } from './utils';\n\nexport class MemMap extends Map<number, number> {\n    private nextFreeMem: number = HEAP_START;\n\n    // Optimistic alloc\n    public alloc = (bytes: number): number => {\n        assertCondition(bytes > 0, 'Cannot alloc 0 words');\n        const nextFree = this.nextFreeMem;\n        this.nextFreeMem += bytes * WORD_SZ;\n        return nextFree;\n    };\n}\n","import { MemMap } from './memMap';\nimport { assertExists } from './utils';\nimport { Label, StringFrag } from '../treeTypes';\n\n/**\n *  StringStorage will handle strings related stuff.\n *\n *  storeString will take a StringFrag (label, string).\n *  It'll store a pointer to that string in memory (pointing\n *  to the index in a private string array) and store that\n *  mem location in the labels map.\n */\nexport class StringStorage {\n    private strings: string[] = [];\n\n    constructor(private memMap: MemMap, private labelMap: Map<Label, number>) {}\n\n    storeString = (stringFrag: StringFrag): number => {\n        const [label, str] = stringFrag.ConstString;\n\n        const addr = this.storeUnlabeledString(str);\n\n        this.labelMap.set(label, addr);\n\n        return addr;\n    };\n\n    storeUnlabeledString = (str: string): number => {\n        const addr = this.memMap.alloc(1);\n        this.strings.push(str);\n        const pointer = this.strings.length - 1;\n\n        this.memMap.set(addr, pointer);\n\n        return addr;\n    };\n\n    loadString = (addr: number): string => {\n        const pointer = assertExists(this.memMap.get(addr));\n        return this.strings[pointer];\n    };\n}\n","import { MemMap } from './utils/memMap';\nimport { assertExists } from './utils/utils';\nimport { StringStorage } from './utils/stringStorage';\nimport { CustomConsole } from '../utils/console';\nimport { WORD_SZ } from '../utils/utils';\nimport { OutOfBoundsException, NilPointerException } from '../utils/runtimeUtils';\nimport { BYTE_SIZE } from '../evaluator/memoryManager';\n\ninterface RuntimeFunctionsByName {\n    print: RuntimeFunction | AsyncRuntimeFunction;\n    flush: RuntimeFunction | AsyncRuntimeFunction;\n    getchar: RuntimeFunction | AsyncRuntimeFunction;\n    getstring: RuntimeFunction | AsyncRuntimeFunction;\n    ord: RuntimeFunction | AsyncRuntimeFunction;\n    chr: RuntimeFunction | AsyncRuntimeFunction;\n    size: RuntimeFunction | AsyncRuntimeFunction;\n    substring: RuntimeFunction | AsyncRuntimeFunction;\n    concat: RuntimeFunction | AsyncRuntimeFunction;\n    not: RuntimeFunction | AsyncRuntimeFunction;\n    debug_words: RuntimeFunction | AsyncRuntimeFunction;\n    debug_bytes: RuntimeFunction | AsyncRuntimeFunction;\n    '+alloc_array': RuntimeFunction | AsyncRuntimeFunction;\n    '+alloc_record': RuntimeFunction | AsyncRuntimeFunction;\n    '+str_equals': RuntimeFunction | AsyncRuntimeFunction;\n    '+str_not_equals': RuntimeFunction | AsyncRuntimeFunction;\n    '+str_less': RuntimeFunction | AsyncRuntimeFunction;\n    '+str_less_or_equals': RuntimeFunction | AsyncRuntimeFunction;\n    '+str_greater': RuntimeFunction | AsyncRuntimeFunction;\n    '+str_greater_or_equals': RuntimeFunction | AsyncRuntimeFunction;\n    '+check_index_array': RuntimeFunction | AsyncRuntimeFunction;\n    '+check_nil': RuntimeFunction | AsyncRuntimeFunction;\n}\n\nexport type RuntimeFunctionNames = keyof RuntimeFunctionsByName;\n\ntype RuntimeFunction = (args: number[]) => number;\ntype AsyncRuntimeFunction = (args: number[]) => Promise<number>;\n\nexport class Runtime {\n    private nameMap: RuntimeFunctionsByName;\n    private arraySizes: Map<number, number>;\n\n    constructor(\n        private memMap: MemMap,\n        private stringStorage: StringStorage,\n        private customConsole: CustomConsole\n    ) {\n        this.arraySizes = new Map();\n        this.nameMap = {\n            print: this.print,\n            flush: this.flush,\n            getchar: this.getchar,\n            getstring: this.getstring,\n            ord: this.ord,\n            chr: this.chr,\n            size: this.size,\n            substring: this.substring,\n            concat: this.concat,\n            not: this.not,\n            debug_words: this.debugWords,\n            debug_bytes: this.debugBytes,\n            '+alloc_array': this.allocArray,\n            '+alloc_record': this.allocRecord,\n            '+str_equals': this.strEquals,\n            '+str_not_equals': this.strNotEquals,\n            '+str_less': this.strLess,\n            '+str_less_or_equals': this.strLessOrEquals,\n            '+str_greater': this.strGreater,\n            '+str_greater_or_equals': this.strGreaterOrEquals,\n            '+check_index_array': this.checkIndexArray,\n            '+check_nil': this.checkNil,\n        };\n    }\n\n    getFunction = (name: RuntimeFunctionNames): RuntimeFunction | AsyncRuntimeFunction => {\n        return this.nameMap[name];\n    };\n\n    maybeGetFunction = (name: string): RuntimeFunction | AsyncRuntimeFunction | undefined => {\n        return this.nameMap[name as RuntimeFunctionNames];\n    };\n\n    /**\n     *  Public functions\n     */\n\n    private print: RuntimeFunction = (args) => {\n        const [strPointer] = args;\n        assertExists(strPointer);\n\n        const str = this.stringStorage.loadString(strPointer);\n        this.customConsole.print(str);\n\n        return 0;\n    };\n\n    private flush: RuntimeFunction = (args) => {\n        return 0;\n    };\n\n    private getchar: AsyncRuntimeFunction = async (args) => {\n        const str = await this.customConsole.readChar();\n        return this.stringStorage.storeUnlabeledString(str[0]);\n    };\n\n    private getstring: AsyncRuntimeFunction = async (args) => {\n        const str = await this.customConsole.read();\n        return this.stringStorage.storeUnlabeledString(str);\n    };\n\n    private ord: RuntimeFunction = (args) => {\n        const [strPointer] = args;\n        assertExists(strPointer);\n\n        const str = this.stringStorage.loadString(strPointer);\n\n        return str.charCodeAt(0);\n    };\n\n    private chr: RuntimeFunction = (args) => {\n        const [charCode] = args;\n        assertExists(charCode);\n\n        const str = String.fromCharCode(charCode);\n        return this.stringStorage.storeUnlabeledString(str);\n    };\n\n    private size: RuntimeFunction = (args) => {\n        const [strPointer] = args;\n        assertExists(strPointer);\n\n        const str = this.stringStorage.loadString(strPointer);\n        return str.length;\n    };\n\n    private substring: RuntimeFunction = (args) => {\n        const [strPointer, start, count] = args;\n        assertExists(strPointer);\n\n        const str = this.stringStorage.loadString(strPointer);\n        const slicedStr = str.slice(start, count);\n\n        return this.stringStorage.storeUnlabeledString(slicedStr);\n    };\n\n    private concat: RuntimeFunction = (args) => {\n        const [leftStrPointer, rightStrPointer] = args;\n        assertExists(leftStrPointer);\n        assertExists(rightStrPointer);\n\n        const leftStr = this.stringStorage.loadString(leftStrPointer);\n        const rightStr = this.stringStorage.loadString(rightStrPointer);\n        const newStr = leftStr + rightStr;\n\n        return this.stringStorage.storeUnlabeledString(newStr);\n    };\n\n    private not: RuntimeFunction = (args) => {\n        const [value] = args;\n        assertExists(value);\n\n        return Number(!value);\n    };\n\n    private debugWords: RuntimeFunction = (args) => {\n        const [pointer, words] = args;\n        assertExists(pointer);\n        assertExists(words);\n\n        for (let i = 0; i < words; i++) {\n            const itemLocation = pointer + i * WORD_SZ;\n\n            console.log(this.memMap.get(itemLocation));\n        }\n\n        return 0;\n    };\n\n    private debugBytes: RuntimeFunction = (args) => {\n        const [pointer, bytes] = args;\n        assertExists(pointer);\n        assertExists(bytes);\n\n        for (let i = 0; i < bytes; i++) {\n            const itemLocation = pointer + i * BYTE_SIZE;\n\n            console.log(this.memMap.get(itemLocation));\n        }\n\n        return 0;\n    };\n\n    /**\n     *  Internal functions\n     */\n\n    private allocArray: RuntimeFunction = (args) => {\n        const [size, init] = args;\n        assertExists(size);\n        assertExists(init);\n\n        const arrayLocation = this.memMap.alloc(size * WORD_SZ);\n        this.arraySizes.set(arrayLocation, size);\n\n        for (let i = 0; i < size; i++) {\n            const itemLocation = arrayLocation + i * WORD_SZ;\n\n            this.memMap.set(itemLocation, init);\n        }\n\n        return arrayLocation;\n    };\n\n    private checkIndexArray: RuntimeFunction = (args) => {\n        const [pointer, index] = args;\n        assertExists(pointer);\n        assertExists(index);\n\n        const size = this.arraySizes.get(pointer);\n\n        if (index < 0 || index >= assertExists(size)) {\n            throw new OutOfBoundsException(index, pointer);\n        }\n\n        return 0;\n    };\n\n    private checkNil: RuntimeFunction = (args) => {\n        const [record] = args;\n        assertExists(record);\n\n        if (record === 0) {\n            throw new NilPointerException();\n        }\n\n        return 0;\n    };\n\n    private allocRecord: RuntimeFunction = (args) => {\n        const [size] = args;\n        assertExists(size);\n\n        const recordLocation = this.memMap.alloc(size * WORD_SZ);\n\n        return recordLocation;\n    };\n\n    private strEquals: RuntimeFunction = (args) => {\n        const comparison = this.strCompare(args);\n        return Number(comparison === 0);\n    };\n\n    private strNotEquals: RuntimeFunction = (args) => {\n        const comparison = this.strCompare(args);\n        return Number(comparison !== 0);\n    };\n\n    private strLess: RuntimeFunction = (args) => {\n        const comparison = this.strCompare(args);\n        return Number(comparison < 0);\n    };\n\n    private strLessOrEquals: RuntimeFunction = (args) => {\n        const comparison = this.strCompare(args);\n        return Number(comparison <= 0);\n    };\n\n    private strGreater: RuntimeFunction = (args) => {\n        const comparison = this.strCompare(args);\n        return Number(comparison > 0);\n    };\n\n    private strGreaterOrEquals: RuntimeFunction = (args) => {\n        const comparison = this.strCompare(args);\n        return Number(comparison >= 0);\n    };\n\n    // extracts the strings and returns their localCompare\n    private strCompare: RuntimeFunction = (args) => {\n        const [leftStrPointer, rightStrPointer] = args;\n\n        const leftStr = this.stringStorage.loadString(assertExists(leftStrPointer));\n        const rightStr = this.stringStorage.loadString(assertExists(rightStrPointer));\n\n        return leftStr.localeCompare(rightStr);\n    };\n}\n","import { Exp, Frag, FunFrag, Stm, Label, GlobalTemp, LocalTemp } from './treeTypes';\nimport { assertExists, UnreachableError, IncludeMap } from './utils/utils';\nimport { accessExpsFromFormals } from './frame';\nimport { findLabelIndex, evalBinop, flatStms } from './utils/treeUtils';\nimport { isFunFrag, isStringFrag } from './utils/fragPatterns';\nimport {\n    isMemExp,\n    isConstExp,\n    isNameExp,\n    isBinopExp,\n    isCallExp,\n    isEseqExp,\n    isLocalExp,\n    isGlobalExp,\n} from './utils/expPatterns';\nimport {\n    isExpStm,\n    isMoveStm,\n    isJumpStm,\n    isCjumpStm,\n    isSeqStm,\n    isLabelStm,\n} from './utils/stmPatterns';\nimport { MemMap } from './utils/memMap';\nimport { StringStorage } from './utils/stringStorage';\nimport { CustomConsole } from '../utils/console';\nimport { Runtime } from './runtime';\n\nconst FRAME_POINTER_OFFSET = 1024 * 1024;\n\nexport class TreeInterpreter {\n    // Map Locals to values, this keeps track of the *current* locals map (per function)\n    private locals: Map<LocalTemp, number>;\n\n    // Map Temps to values\n    private globals: Map<GlobalTemp, number>;\n\n    // Map Labels to mem locations\n    private labels: Map<Label, number>;\n\n    // Map memory location to values\n    private mem: MemMap;\n\n    // String storage\n    private stringStorage: StringStorage;\n\n    // Fragments corresponding to functions.\n    private functions: IncludeMap<FunFrag>;\n\n    // Provides runtime functions\n    private runtime: Runtime;\n\n    constructor(fragments: Frag[], private customConsole: CustomConsole) {\n        this.locals = new Map();\n        this.globals = new Map();\n        this.labels = new Map();\n        this.mem = new MemMap();\n        this.stringStorage = new StringStorage(this.mem, this.labels);\n        this.functions = new IncludeMap();\n\n        fragments.filter(isFunFrag).forEach((frag) => {\n            this.functions.set(frag.Proc.frame.label, frag);\n        });\n\n        fragments.filter(isStringFrag).forEach((frag) => {\n            this.stringStorage.storeString(frag);\n        });\n\n        this.runtime = new Runtime(this.mem, this.stringStorage, this.customConsole);\n    }\n\n    public run = async (): Promise<number> => {\n        // A program starts by calling the function _tigermain\n        const mainLabel = '_tigermain';\n        return await this.evalFunction(mainLabel, [0]);\n    };\n\n    private evalFunction = async (name: string, args: number[]): Promise<number> => {\n        // Find the function and extract it's body and frame.\n        const fragment = assertExists(\n            this.functions.get(name),\n            `Could not find function named '${name}'`\n        );\n        const { body, frame } = fragment.Proc;\n\n        // Store locals for the current function\n        const localsToRestore = this.locals;\n        this.locals = new Map();\n\n        // Move FP very far away from here\n        const prevFp = this.globals.get('fp') ?? 0;\n        this.globals.set('fp', prevFp + FRAME_POINTER_OFFSET);\n\n        // Set up the formals so we can exec the body\n        await this.setupFormals(args, frame.formals);\n\n        // The machine state is ready to run the body, do it.\n        await this.execStms(flatStms(body));\n\n        // Restore locals\n        this.locals = localsToRestore;\n\n        // Retreive the return value, default to 0\n        const rv = this.globals.get('rv') ?? 0;\n\n        this.globals.set('fp', prevFp);\n\n        return rv;\n    };\n\n    /**\n     *  Execute stms in order, there may be internal jumps\n     *  to previous or following stms. This can loop forever!\n     */\n    private execStms = async (stms: Stm[]): Promise<void> => {\n        // Start executing the first stm\n        let executedStmIndex = 0;\n\n        while (executedStmIndex < stms.length) {\n            const stm = stms[executedStmIndex];\n\n            // Evaluate the current stm\n            const maybeLabel: Label | null = await this.evalStm(stm);\n\n            // Find the next stm to evaluate\n            if (maybeLabel === null) {\n                // If no jump continue executing the next stm\n                executedStmIndex++;\n            } else if (maybeLabel === 'done') {\n                // If the label is 'done', the program finished.\n                break;\n            } else {\n                // We've got a label, find the corresponding stm and continue executing from there\n                const nextStmIndex = findLabelIndex(stms, maybeLabel);\n                executedStmIndex = nextStmIndex;\n            }\n        }\n    };\n\n    // Store each value from args in the corresponding temp/mem location\n    private setupFormals = async (args: number[], formals: [string, boolean][]): Promise<void> => {\n        const accessExps = accessExpsFromFormals(formals);\n\n        for (let i = 0; i < args.length; i++) {\n            const arg = args[i];\n            const access = accessExps[i];\n\n            if (isGlobalExp(access)) {\n                // Evaluate the memory location and store the arg there\n                this.globals.set(access.GLOBAL, arg);\n            } else if (isLocalExp(access)) {\n                // Store the argument in the corresponding temp\n                this.locals.set(access.LOCAL, arg);\n            } else {\n                // The access can be either MEM or TEMP.\n                throw new UnreachableError();\n            }\n        }\n    };\n\n    /**\n     *  Evaluate a Stm.\n     *  Return a Label if we need to jump somewhere, null otherwise\n     */\n    private evalStm = async (stm: Stm): Promise<Label | null> => {\n        if (isExpStm(stm)) {\n            await this.evalExp(stm.EXP);\n            return null;\n        }\n\n        if (isMoveStm(stm)) {\n            const [toExp, fromExp] = stm.MOVE;\n            if (isLocalExp(toExp)) {\n                const value: number = await this.evalExp(fromExp);\n\n                this.locals.set(toExp.LOCAL, value);\n                return null;\n            }\n\n            if (isGlobalExp(toExp)) {\n                const value: number = await this.evalExp(fromExp);\n\n                this.globals.set(toExp.GLOBAL, value);\n                return null;\n            }\n\n            if (isMemExp(toExp)) {\n                const location: number = await this.evalExp(toExp.MEM);\n                const value: number = await this.evalExp(fromExp);\n\n                this.mem.set(location, value);\n                return null;\n            }\n\n            throw new UnreachableError(`MOVE to a non Local, Global or Mem expression\\n${toExp}\\n`);\n        }\n\n        if (isJumpStm(stm)) {\n            const [where] = stm.JUMP;\n            if (isNameExp(where)) {\n                return where.NAME;\n            }\n\n            throw new UnreachableError(`JUMP to a non Label expression:\\n${where}\\n`);\n        }\n\n        if (isCjumpStm(stm)) {\n            const [op, leftExp, rightExp, labelTrue, labelFalse] = stm.CJUMP;\n\n            const leftVal = await this.evalExp(leftExp);\n            const rightVal = await this.evalExp(rightExp);\n\n            // 0 means false, everything else means true.\n            const condition = evalBinop(op, leftVal, rightVal);\n            return condition === 0 ? labelFalse : labelTrue;\n        }\n\n        if (isSeqStm(stm)) {\n            throw new UnreachableError('Found SEQ, not a canonical tree!');\n        }\n\n        if (isLabelStm(stm)) {\n            return null;\n        }\n\n        // No more cases\n        throw new UnreachableError();\n    };\n\n    /**\n     *  Evaluate an Exp.\n     *  Every exp evaluates to a number.\n     */\n    private evalExp = async (exp: Exp): Promise<number> => {\n        if (isConstExp(exp)) {\n            return exp.CONST;\n        }\n\n        if (isNameExp(exp)) {\n            return assertExists(\n                this.labels.get(exp.NAME),\n                `Could not find label called '${exp.NAME}'`\n            );\n        }\n\n        if (isLocalExp(exp)) {\n            return assertExists(\n                this.locals.get(exp.LOCAL),\n                `Could not find local called '${exp.LOCAL}'`\n            );\n        }\n\n        if (isGlobalExp(exp)) {\n            return assertExists(\n                this.globals.get(exp.GLOBAL),\n                `Could not find global called '${exp.GLOBAL}'`\n            );\n        }\n\n        if (isBinopExp(exp)) {\n            const [op, leftExp, rightExp] = exp.BINOP;\n\n            const leftVal = await this.evalExp(leftExp);\n            const rightVal = await this.evalExp(rightExp);\n\n            return evalBinop(op, leftVal, rightVal);\n        }\n\n        if (isMemExp(exp)) {\n            const dir = await this.evalExp(exp.MEM);\n            return assertExists(this.mem.get(dir), `Memory location ${dir} is empty!`);\n        }\n\n        if (isCallExp(exp)) {\n            const [labelExp, args] = exp.CALL;\n            if (isNameExp(labelExp)) {\n                const name = labelExp.NAME;\n                const evaluatedArgs = await Promise.all(args.map(this.evalExp));\n\n                let returnValue: number;\n                const runtimeFunction = this.runtime.maybeGetFunction(name);\n                if (runtimeFunction !== undefined) {\n                    returnValue = await runtimeFunction(evaluatedArgs);\n                } else {\n                    returnValue = await this.evalFunction(name, evaluatedArgs);\n                }\n\n                this.globals.set('rv', returnValue);\n\n                return returnValue;\n            } else {\n                throw new UnreachableError('Found CALL to non NAME exp');\n            }\n        }\n\n        if (isEseqExp(exp)) {\n            throw new UnreachableError('Found ESEQ, not a canonical tree!');\n        }\n\n        // No more cases\n        throw new UnreachableError();\n    };\n}\n","import React from 'react';\nimport { CanonResult } from '../Compiler/CompilerInterface';\nimport { CustomConsole } from '../CustomConsole/CustomConsole';\nimport { useConsole } from '../../hooks/useConsole';\nimport { useInterpreter } from '../../hooks/useInterpreter';\n\ninterface InterpreterOkProps {\n    frags: CanonResult;\n}\n\nexport const InterpreterOk: React.FC<InterpreterOkProps> = (props) => {\n    const { frags } = props;\n    const [customConsole, messages, isReading, isReadingChar] = useConsole();\n\n    const [run, isRunning] = useInterpreter(customConsole, frags);\n\n    return (\n        <div className=\"interpreter-container\">\n            <CustomConsole\n                customConsole={customConsole}\n                messages={messages}\n                isReading={isReading}\n                isReadingChar={isReadingChar}\n            />\n            <RunButton disabled={isRunning} onClick={run} />\n        </div>\n    );\n};\n\ninterface RunButtonProps {\n    onClick: () => void;\n    disabled: boolean;\n}\n\nconst RunButton: React.FC<RunButtonProps> = (props) => {\n    return (\n        <button className=\"run-button\" disabled={props.disabled} onClick={props.onClick}>\n            Run interpreter\n        </button>\n    );\n};\n","import { UserConsole } from './useConsole';\nimport { Frag } from '../interpreter/treeTypes';\nimport { TreeInterpreter } from '../interpreter/interpreter';\nimport { useMemo, useState, useCallback } from 'react';\nimport { OutOfBoundsException, NilPointerException } from '../utils/runtimeUtils';\n\nexport type RunFunction = () => Promise<void>;\n\nexport const useInterpreter = (\n    customConsole: UserConsole,\n    frags: Frag[]\n): [RunFunction, boolean] => {\n    const [isRunning, setIsRunning] = useState<boolean>(false);\n\n    const interpreter = useMemo(() => new TreeInterpreter(frags, customConsole), [\n        frags,\n        customConsole,\n    ]);\n\n    const run = useCallback(async () => {\n        customConsole.clear();\n        setIsRunning(true);\n        try {\n            const result = await interpreter.run();\n            customConsole.printLine(`Program ended returning ${result}`);\n        } catch (err) {\n            if (err instanceof OutOfBoundsException) {\n                customConsole.print(\n                    `Program failed!\\nArray index out of bounds.\\nCannot access index ${err.index} from pointer ${err.pointer}`\n                );\n            } else if (err instanceof NilPointerException) {\n                customConsole.print(\n                    `Program failed!\\nNil record exception.\\nCannot access a field of a nil record`\n                );\n            } else {\n                console.error(err);\n                customConsole.print(\n                    `Program failed with message:\\n${err.message}\\n\\nCheck the console for a stack trace`\n                );\n            }\n        }\n        setIsRunning(false);\n    }, [interpreter, customConsole]);\n\n    return [run, isRunning];\n};\n","import React from 'react';\nimport { CanonResult } from '../Compiler/CompilerInterface';\nimport { InterpreterOk } from './InterpreterOk';\n\nimport './Interpreter.scss';\n\ninterface InterpreterProps {\n    canon: CanonResult | null;\n}\nexport const Interpreter: React.FC<InterpreterProps> = (props) => {\n    if (props.canon === null) {\n        return <InterpreterErr />;\n    } else {\n        return <InterpreterOk frags={props.canon} />;\n    }\n};\n\nconst InterpreterErr: React.FC = () => {\n    return (\n        <div className=\"interpreter-container\">\n            <h3>No fragments to show!</h3>\n            <p>Did you compile the code?</p>\n            <p>If so, check the WASM results to see if there were any errors</p>\n        </div>\n    );\n};\n","import { MemoryManager } from './memoryManager';\n\nexport class StringStorage {\n    constructor(private memoryManager: MemoryManager) {}\n\n    readString = (strPointer: number): string => {\n        let string = '';\n        for (let i = 0; true; i++) {\n            const encodedChar = this.memoryManager.byteGet(strPointer + i);\n\n            if (encodedChar === 0) {\n                break;\n            }\n\n            string += String.fromCharCode(encodedChar);\n        }\n\n        return string;\n    };\n\n    writeString = (str: string): number => {\n        const pointer = this.memoryManager.alloc(str.length + 1);\n        for (let i = 0; i < str.length; i++) {\n            const charCode = str.charCodeAt(i);\n            this.memoryManager.byteStore(pointer + i, charCode);\n        }\n        this.memoryManager.byteStore(pointer + str.length, 0);\n\n        return pointer;\n    };\n}\n","const WRAPPED_EXPORTS = new WeakMap();\n\nfunction isPromise(obj) {\n    return (\n        !!obj &&\n        (typeof obj === 'object' || typeof obj === 'function') &&\n        typeof obj.then === 'function'\n    );\n}\n\nfunction proxyGet(obj, transform) {\n    return new Proxy(obj, {\n        get: (obj, name) => transform(obj[name]),\n    });\n}\n\nclass Asyncify {\n    constructor(dataAddr, dataEnd) {\n        this.dataAddr = dataAddr;\n        this.dataEnd = dataEnd;\n        this.dataStart = this.dataAddr + 8;\n        this.state = { type: 'Loading' };\n        this.exports = null;\n    }\n\n    assertNoneState() {\n        if (this.state.type !== 'None') {\n            throw new Error(`Invalid async state ${this.state.type}`);\n        }\n    }\n\n    wrapImportFn(fn) {\n        return (...args) => {\n            if (this.state.type === 'Rewinding') {\n                let { value } = this.state;\n                this.state = { type: 'None' };\n                this.exports.asyncify_stop_rewind();\n                return value;\n            }\n            this.assertNoneState();\n            let value = fn(...args);\n            if (!isPromise(value)) {\n                return value;\n            }\n            this.exports.asyncify_start_unwind(this.dataAddr);\n            this.state = {\n                type: 'Unwinding',\n                promise: value,\n            };\n        };\n    }\n\n    wrapModuleImports(module) {\n        return proxyGet(module, (value) => {\n            if (typeof value === 'function') {\n                return this.wrapImportFn(value);\n            }\n            return value;\n        });\n    }\n\n    wrapImports(imports) {\n        if (imports === undefined) return;\n\n        return proxyGet(imports, (moduleImports) => this.wrapModuleImports(moduleImports));\n    }\n\n    wrapExportFn(fn) {\n        let newExport = WRAPPED_EXPORTS.get(fn);\n\n        if (newExport !== undefined) {\n            return newExport;\n        }\n\n        newExport = async (...args) => {\n            this.assertNoneState();\n\n            let result = fn(...args);\n\n            while (this.state.type === 'Unwinding') {\n                let { promise } = this.state;\n                this.state = { type: 'None' };\n                this.exports.asyncify_stop_unwind();\n                let value = await promise;\n                this.assertNoneState();\n                this.exports.asyncify_start_rewind(this.dataAddr);\n                this.state = {\n                    type: 'Rewinding',\n                    value,\n                };\n                result = fn();\n            }\n\n            this.assertNoneState();\n\n            return result;\n        };\n\n        WRAPPED_EXPORTS.set(fn, newExport);\n\n        return newExport;\n    }\n\n    wrapExports(exports) {\n        let newExports = Object.create(null);\n\n        for (let exportName in exports) {\n            let value = exports[exportName];\n            if (typeof value === 'function' && !exportName.startsWith('asyncify_')) {\n                value = this.wrapExportFn(value);\n            }\n            Object.defineProperty(newExports, exportName, {\n                enumerable: true,\n                value,\n            });\n        }\n\n        WRAPPED_EXPORTS.set(exports, newExports);\n\n        return newExports;\n    }\n\n    init(instance, imports) {\n        const { exports } = instance;\n\n        const memory = exports.memory || (imports.mem && imports.mem.memory);\n\n        new Int32Array(memory.buffer, this.dataAddr).set([this.dataStart, this.dataEnd]);\n\n        this.state = { type: 'None' };\n\n        this.exports = this.wrapExports(exports);\n\n        Object.setPrototypeOf(instance, Instance.prototype);\n    }\n}\n\nexport class Instance extends WebAssembly.Instance {\n    constructor(module, dataAddr, dataEnd, imports) {\n        let state = new Asyncify(dataAddr, dataEnd);\n        super(module, state.wrapImports(imports));\n        state.init(this, imports);\n    }\n\n    get exports() {\n        return WRAPPED_EXPORTS.get(super.exports);\n    }\n}\n\nObject.defineProperty(Instance.prototype, 'exports', { enumerable: true });\n\nexport async function instantiate(source, dataAddr, dataEnd, imports) {\n    let state = new Asyncify(dataAddr, dataEnd);\n    let result = await WebAssembly.instantiate(source, state.wrapImports(imports));\n    state.init(result instanceof WebAssembly.Instance ? result : result.instance, imports);\n    return result;\n}\n","import { CustomConsole } from '../utils/console';\nimport {\n    MemoryManager,\n    MEMORY_PAGES,\n    ASYNCIFY_DATA_START,\n    ASYNCIFY_DATA_END,\n} from './memoryManager';\nimport { StringStorage } from './stringStorage';\nimport { RuntimeExit, NilPointerException } from '../utils/runtimeUtils';\nimport * as Asyncify from './asyncify';\nimport { WORD_SZ } from '../utils/utils';\n\ntype TigerMain = () => Promise<number>;\n\nexport class Runtime {\n    private memoryManager: MemoryManager;\n    private stringStorage: StringStorage;\n    private instanceImports: Record<string, Record<string, WebAssembly.ImportValue>>;\n\n    constructor(private binary: Uint8Array, private customConsole: CustomConsole) {\n        const memory = new WebAssembly.Memory({ initial: MEMORY_PAGES, maximum: MEMORY_PAGES });\n\n        this.memoryManager = new MemoryManager(new Uint8Array(memory.buffer));\n        this.stringStorage = new StringStorage(this.memoryManager);\n        this.instanceImports = {\n            mem: {\n                memory,\n            },\n            externals: {\n                print: this.print,\n                flush: this.flush,\n                getchar: this.getchar,\n                getstring: this.getstring,\n                ord: this.ord,\n                chr: this.chr,\n                size: this.size,\n                substring: this.substring,\n                concat: this.concat,\n                not: this.not,\n                exit: this.exit,\n                alloc_array: this.alloc_array,\n                alloc_record: this.alloc_record,\n                debug_words: this.debug_words,\n                debug_bytes: this.debug_bytes,\n                check_index_array: this.check_index_array,\n                check_nil: this.check_nil,\n                str_equals: this.str_equals,\n                str_not_equals: this.str_not_equals,\n                str_less: this.str_less,\n                str_less_or_equals: this.str_less_or_equals,\n                str_greater: this.str_greater,\n                str_greater_or_equals: this.str_greater_or_equals,\n            },\n        };\n    }\n\n    run = async (): Promise<number> => {\n        try {\n            const wasmInstance = await Asyncify.instantiate(\n                this.binary,\n                ASYNCIFY_DATA_START,\n                ASYNCIFY_DATA_END,\n                this.instanceImports\n            );\n\n            const main = wasmInstance.instance.exports.tigermain_wrapper as TigerMain;\n            const execution = await main();\n\n            return execution;\n        } catch (err) {\n            if (err instanceof RuntimeExit) {\n                return err.exitCode;\n            } else {\n                throw err;\n            }\n        }\n    };\n\n    private print = (strPointer: number): number => {\n        const string = this.stringStorage.readString(strPointer);\n        this.customConsole.print(string);\n        return 0;\n    };\n    private flush = (): number => {\n        return 0;\n    };\n    private getchar = async (): Promise<number> => {\n        const string = await this.customConsole.readChar();\n        return this.stringStorage.writeString(string);\n    };\n    private getstring = async (): Promise<number> => {\n        const string = await this.customConsole.read();\n        return this.stringStorage.writeString(string);\n    };\n    private ord = (strPointer: number): number => {\n        const string = this.stringStorage.readString(strPointer);\n        return string.charCodeAt(0);\n    };\n    private chr = (charCode: number): number => {\n        const string = String.fromCharCode(charCode);\n        return this.stringStorage.writeString(string);\n    };\n    private size = (strPointer: number): number => {\n        const string = this.stringStorage.readString(strPointer);\n        return string.length;\n    };\n    private substring = (strPointer: number, start: number, end: number): number => {\n        const string = this.stringStorage.readString(strPointer);\n        const slicedString = string.slice(start, end);\n        const newStrPointer = this.stringStorage.writeString(slicedString);\n        return newStrPointer;\n    };\n    private concat = (str1Pointer: number, str2Pointer: number): number => {\n        const str1 = this.stringStorage.readString(str1Pointer);\n        const str2 = this.stringStorage.readString(str2Pointer);\n\n        return this.stringStorage.writeString(str1 + str2);\n    };\n    private not = (condition: number): number => {\n        return Number(!condition);\n    };\n    private exit = (exitCode: number) => {\n        throw new RuntimeExit(exitCode);\n    };\n    private alloc_array = (size: number, init: number): number => {\n        const pointer = this.memoryManager.alloc(size * WORD_SZ);\n        for (let i = 0; i < size; i++) {\n            const dir = pointer + i * WORD_SZ;\n            this.memoryManager.wordStore(dir, init);\n        }\n\n        return pointer;\n    };\n    private alloc_record = (size: number): number => {\n        const pointer = this.memoryManager.alloc(size * WORD_SZ);\n        console.log(`Alloc'd record in ${pointer}`);\n        return pointer;\n    };\n    private debug_words = (pointer: number, words: number) => {\n        console.log(`Will print ${words} words from pointer ${pointer}`);\n        this.memoryManager.wordDebugSlice(pointer, words);\n        return 0;\n    };\n    private debug_bytes = (pointer: number, bytes: number) => {\n        console.log(`Will print ${bytes} bytes from pointer ${pointer}`);\n        this.memoryManager.byteDebugSlice(pointer, bytes);\n        return 0;\n    };\n    private check_index_array = (pointer: number, index: number): number => {\n        this.memoryManager.checkArrayIndex(pointer, index);\n        return 0;\n    };\n    private check_nil = (record: number): number => {\n        if (record === 0) {\n            throw new NilPointerException();\n        }\n        return 0;\n    };\n    private str_equals = (leftStrPointer: number, rightStrPointer: number): number => {\n        const comparison = this.strCompare(leftStrPointer, rightStrPointer);\n\n        return Number(comparison === 0);\n    };\n    private str_not_equals = (leftStrPointer: number, rightStrPointer: number): number => {\n        const comparison = this.strCompare(leftStrPointer, rightStrPointer);\n\n        return Number(comparison !== 0);\n    };\n    private str_less = (leftStrPointer: number, rightStrPointer: number): number => {\n        const comparison = this.strCompare(leftStrPointer, rightStrPointer);\n\n        return Number(comparison < 0);\n    };\n    private str_less_or_equals = (leftStrPointer: number, rightStrPointer: number): number => {\n        const comparison = this.strCompare(leftStrPointer, rightStrPointer);\n\n        return Number(comparison <= 0);\n    };\n    private str_greater = (leftStrPointer: number, rightStrPointer: number): number => {\n        const comparison = this.strCompare(leftStrPointer, rightStrPointer);\n\n        return Number(comparison > 0);\n    };\n    private str_greater_or_equals = (leftStrPointer: number, rightStrPointer: number): number => {\n        const comparison = this.strCompare(leftStrPointer, rightStrPointer);\n\n        return Number(comparison >= 0);\n    };\n\n    private strCompare = (leftStrPointer: number, rightStrPointer: number): number => {\n        const leftStr = this.stringStorage.readString(leftStrPointer);\n        const rightStr = this.stringStorage.readString(rightStrPointer);\n\n        return leftStr.localeCompare(rightStr);\n    };\n}\n","import { CustomConsole } from '../utils/console';\nimport binaryen from 'binaryen';\nimport { Runtime } from './runtime';\n\nexport interface Evaluator {\n    run(): Promise<number>;\n}\n\nexport class WasmEvaluator implements Evaluator {\n    private runtime: Runtime;\n\n    constructor(binaryWasm: Uint8Array, customConsole: CustomConsole) {\n        const wasmModule = binaryen.readBinary(binaryWasm);\n        binaryen.setOptimizeLevel(1);\n        wasmModule.runPasses(['asyncify']);\n        const binary = wasmModule.emitBinary();\n\n        this.runtime = new Runtime(binary, customConsole);\n    }\n\n    run = async () => {\n        return this.runtime.run();\n    };\n}\n","import React from 'react';\nimport { CustomConsole } from '../CustomConsole/CustomConsole';\nimport { useConsole } from '../../hooks/useConsole';\nimport { useEvaluator } from '../../hooks/useEvaluator';\n\ninterface EvaluatorOkProps {\n    bin: any;\n}\n\nexport const EvaluatorOk: React.FC<EvaluatorOkProps> = (props) => {\n    const { bin } = props;\n    const [customConsole, messages, isReading, isReadingChar] = useConsole();\n\n    const [run, isRunning] = useEvaluator(customConsole, bin);\n\n    return (\n        <div className=\"evaluator-container\">\n            <CustomConsole\n                customConsole={customConsole}\n                messages={messages}\n                isReading={isReading}\n                isReadingChar={isReadingChar}\n            />\n            <RunButton disabled={isRunning} onClick={run} />\n        </div>\n    );\n};\n\ninterface RunButtonProps {\n    onClick: () => void;\n    disabled: boolean;\n}\n\nconst RunButton: React.FC<RunButtonProps> = (props) => {\n    return (\n        <button className=\"run-button\" disabled={props.disabled} onClick={props.onClick}>\n            Run program\n        </button>\n    );\n};\n","import { UserConsole } from './useConsole';\nimport { useMemo, useState, useCallback } from 'react';\nimport { WasmEvaluator } from '../evaluator/evaluator';\nimport { OutOfBoundsException, NilPointerException } from '../utils/runtimeUtils';\n\nexport type RunFunction = () => Promise<void>;\n\nexport const useEvaluator = (customConsole: UserConsole, bin: any): [RunFunction, boolean] => {\n    const [isRunning, setIsRunning] = useState<boolean>(false);\n\n    const evaluator = useMemo(() => new WasmEvaluator(Uint8Array.from(bin), customConsole), [\n        bin,\n        customConsole,\n    ]);\n\n    const run = useCallback(async () => {\n        customConsole.clear();\n        setIsRunning(true);\n        try {\n            const result = await evaluator.run();\n            customConsole.printLine(`Program ended returning ${result}`);\n        } catch (err) {\n            if (err instanceof OutOfBoundsException) {\n                customConsole.print(\n                    `Program failed!\\nArray index out of bounds.\\nCannot access index ${err.index} from pointer ${err.pointer}`\n                );\n            } else if (err instanceof NilPointerException) {\n                customConsole.print(\n                    `Program failed!\\nNil record exception.\\nCannot access a field of a nil record`\n                );\n            } else {\n                console.error(err);\n                customConsole.printLine(\n                    `Program failed with message:\\n${err.message}\\n\\nCheck the console for a stack trace`\n                );\n            }\n        }\n        setIsRunning(false);\n    }, [evaluator, customConsole]);\n\n    return [run, isRunning];\n};\n","import React, { ErrorInfo } from 'react';\n\ninterface ErrorBoundaryProps {\n    fallback: React.ReactNode;\n    children: React.ReactNode;\n}\n\ninterface ErrorBoundaryState {\n    error: Error | null;\n}\n\nexport class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {\n    readonly state = {\n        error: null,\n    };\n\n    static getDerivedStateFromError(error: Error) {\n        return { error };\n    }\n\n    componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n        console.error(error, errorInfo);\n    }\n\n    render(): JSX.Element {\n        if (this.state.error !== null) {\n            return <>{this.props.fallback}</>;\n        }\n\n        return <>{this.props.children}</>;\n    }\n}\n","import React from 'react';\nimport { EvaluatorOk } from './EvaluatorOk';\nimport { ErrorBoundary } from './ErrorBoundary';\nimport './Evaluator.scss';\n\ninterface EvaluatorProps {\n    bin: any;\n}\n\nexport const Evaluator: React.FC<EvaluatorProps> = (props) => {\n    if (props.bin === null) {\n        return <EvaluatorError />;\n    } else {\n        return (\n            <ErrorBoundary fallback={<EvaluatorError />}>\n                <EvaluatorOk bin={props.bin} />\n            </ErrorBoundary>\n        );\n    }\n};\n\nconst EvaluatorError: React.FC = () => {\n    return (\n        <div className=\"evaluator-container\">\n            <h3>Something went wrong compiling the code!</h3>\n            <p>Check the console for further info</p>\n        </div>\n    );\n};\n","import React from 'react';\n\nexport interface TabProps {\n    name: string;\n    children: React.ReactNode;\n}\n\nexport const Tab: React.FC<TabProps> = (props) => {\n    return <>{props.children}</>;\n};\n","import React, { useState, useCallback } from 'react';\nimport { TabProps } from './Tab';\nimport { isNil } from '../../utils/utils';\nimport { useCtrlAltKeys } from '../../hooks/useCtrlAltKeys';\nimport './Tabs.scss';\n\ninterface TabsProps {\n    children: React.ReactNode;\n}\n\n// Should only receive Tab components\nexport const Tabs: React.FC<TabsProps> = (props) => {\n    const [selectedIndex, setSelectedIndex] = useState(0);\n\n    const names = React.Children.map(props.children, (child) => {\n        if (!child) {\n            throw new Error('Tabs component must have Tab children');\n        }\n\n        const anyChild = child as any;\n        if (!anyChild.props) {\n            throw new Error('Tabs component must have Tab children');\n        }\n\n        const props = anyChild.props as TabProps;\n        if (!props.name) {\n            throw new Error('Tabs component must have Tab children');\n        }\n\n        return props.name;\n    });\n\n    if (isNil(names)) {\n        throw new Error('Tabs component must have Tab children');\n    }\n\n    const tabsArray = React.Children.toArray(props.children);\n    const visibleTab = tabsArray[selectedIndex];\n\n    return (\n        <div className=\"tabs-container\">\n            <TabsButtons\n                names={names}\n                selectedIndex={selectedIndex}\n                setSelectedIndex={setSelectedIndex}\n            />\n            {visibleTab}\n        </div>\n    );\n};\n\ninterface TabsButtonsProps {\n    names: string[];\n    selectedIndex: number;\n    setSelectedIndex: React.Dispatch<React.SetStateAction<number>>;\n}\nconst TabsButtons: React.FC<TabsButtonsProps> = ({ names, selectedIndex, setSelectedIndex }) => {\n    return (\n        <div className=\"tabs-buttons\">\n            {names.map((name, index) => (\n                <TabButton\n                    key={name}\n                    name={name}\n                    index={index}\n                    selectedIndex={selectedIndex}\n                    setSelectedIndex={setSelectedIndex}\n                />\n            ))}\n        </div>\n    );\n};\n\ninterface TabButtonProps {\n    name: string;\n    index: number;\n    selectedIndex: number;\n    setSelectedIndex: React.Dispatch<React.SetStateAction<number>>;\n}\n\nconst TabButton: React.FC<TabButtonProps> = ({ name, index, selectedIndex, setSelectedIndex }) => {\n    const selectedClass = index === selectedIndex ? 'selected' : '';\n\n    const moveToTab = useCallback(() => {\n        setSelectedIndex(index);\n    }, [index, setSelectedIndex]);\n    useCtrlAltKeys([49 + index], moveToTab);\n\n    return (\n        <button key={name} className={selectedClass} onClick={moveToTab}>\n            {name}\n        </button>\n    );\n};\n","import { useEffect } from 'react';\n\nexport const useCtrlAltKeys = (compileKeyCodes: number[], handler: () => void): void => {\n    useEffect(() => {\n        const keyHandler = (e: KeyboardEvent): void => {\n            if (compileKeyCodes.includes(e.keyCode) && e.ctrlKey && e.altKey) {\n                handler();\n                e.preventDefault();\n            }\n        };\n\n        document.addEventListener('keydown', keyHandler);\n\n        return () => {\n            document.removeEventListener('keydown', keyHandler);\n        };\n    }, [handler, compileKeyCodes]);\n};\n","import React from 'react';\nimport { useWatFromWasm } from '../../hooks/useWatFromWasm';\nimport './WASMViewer.scss';\n\ninterface WASMViewerProps {\n    bin: any;\n}\n\nexport const WASMViewer: React.FC<WASMViewerProps> = ({ bin }) => {\n    const wat = useWatFromWasm(bin);\n    return (\n        <div className=\"wat-container\">\n            <pre>{wat}</pre>\n        </div>\n    );\n};\n","import binaryen from 'binaryen';\nimport { useMemo } from 'react';\n\nexport const useWatFromWasm = (bin: any): string => {\n    const memoizedText = useMemo(() => {\n        const wasmModule = binaryen.readBinary(bin);\n        return wasmModule.emitText();\n    }, [bin]);\n\n    return memoizedText;\n};\n","import React from 'react';\nimport { CodeEditor } from '../CodeEditor/CodeEditor';\nimport { ASTViewer } from '../ASTViewer/ASTViewer';\nimport { TREEViewer } from '../TREEViewer/TREEViewer';\nimport { CanonViewer } from '../CanonViewer/CanonViewer';\nimport { Interpreter } from '../Interpreter/Interpreter';\nimport { Frag } from '../../interpreter/treeTypes';\nimport { useLocalStorageState } from '../../hooks/useLocalStorageState';\nimport { baseCode } from '../../utils/baseCode';\nimport { Evaluator } from '../Evaluator/Evaluator';\nimport { Tab } from '../Tabs/Tab';\nimport { Tabs } from '../Tabs/Tabs';\nimport { WASMViewer } from '../WASMViewer/WASMViewer';\nimport { useCompileResult } from '../../hooks/useCompileResult';\n\n// Bad type. You can get either Ok or Err. Improve this.\nexport type RustOption<T> = {\n    Ok?: T;\n    Err?: any;\n};\n\nexport type ParseResult = RustOption<any> | null;\nexport type TypecheckResult = RustOption<any> | null;\nexport type EscapeResult = any;\nexport type TranslateResult = RustOption<any> | null;\nexport type CanonResult = Frag[];\nexport type WasmResult = any; // Not implemented\n\nexport interface CompileResult {\n    parse: ParseResult;\n    typecheck: ParseResult;\n    escape: any;\n    translate: ParseResult;\n    canon: CanonResult | null;\n    wasm: string | null;\n    bin: any;\n}\n\nexport type CompileFunction = (source: string) => CompileResult;\n\ninterface CompilerProps {\n    compile: CompileFunction;\n}\n\nexport const CompilerInterface: React.FC<CompilerProps> = ({ compile }) => {\n    const [code, setCode] = useLocalStorageState<string>('hector-code', baseCode);\n\n    const compileResult = useCompileResult(code, compile);\n\n    return (\n        <div className=\"compiler-interface\">\n            <Tabs>\n                <Tab name=\"Editor\">\n                    <CodeEditor compileCode={setCode} />\n                </Tab>\n                <Tab name=\"AST\">\n                    <ASTViewer ast={compileResult.escape} />\n                </Tab>\n                <Tab name=\"TREE\">\n                    <TREEViewer fragments={compileResult.translate} />\n                </Tab>\n                <Tab name=\"Canon\">\n                    <CanonViewer canon={compileResult.canon} />\n                </Tab>\n                <Tab name=\"WASM\">\n                    <WASMViewer bin={compileResult.bin} />\n                </Tab>\n                <Tab name=\"Interpreter\">\n                    <Interpreter canon={compileResult.canon} />\n                </Tab>\n                <Tab name=\"Evaluator\">\n                    <Evaluator bin={compileResult.bin} />\n                </Tab>\n            </Tabs>\n            <p className=\"compile-instructions\">\n                Psst! compile the code with <strong>Ctrl + enter</strong> or{' '}\n                <strong>Ctrl + s</strong>\n            </p>\n        </div>\n    );\n};\n","import { CompileResult, CompileFunction } from '../components/Compiler/CompilerInterface';\nimport { useMemo } from 'react';\n\nexport const useCompileResult = (code: string, compile: CompileFunction): CompileResult => {\n    const compileResult: CompileResult = useMemo(() => {\n        try {\n            const result = compile(code);\n            console.log(result);\n            return result;\n        } catch (err) {\n            console.log('Something went wrong compiling your code!');\n            console.error(err);\n            return {\n                parse: null,\n                typecheck: null,\n                escape: null,\n                translate: null,\n                canon: null,\n                wasm: null,\n                bin: null,\n            };\n        }\n    }, [compile, code]);\n\n    return compileResult;\n};\n","import React, { Suspense } from 'react';\nimport { CompilerInterface } from './CompilerInterface';\n\nimport './Compiler.scss';\n\nconst AsyncCompiler = React.lazy(\n    async (): Promise<any> => {\n        const wasm = await import('hector');\n        const Component: React.FC = () => <CompilerInterface compile={wasm.compile} />;\n\n        return { default: Component };\n    }\n);\n\nexport const Compiler: React.FC = () => {\n    return (\n        <div className=\"compiler-container\">\n            <Suspense fallback={<div>Loading...</div>}>\n                <AsyncCompiler />\n            </Suspense>\n        </div>\n    );\n};\n","import React from 'react';\nimport './Header.scss';\n\nexport const Header: React.FC = () => {\n    return (\n        <header className=\"header-container\">\n            <h1 className=\"title\">HECTOR</h1>\n            <span className=\"description\">Heuristically Excessive Compiler for Tiger On Rust</span>\n        </header>\n    );\n};\n","import React from 'react';\nimport { Compiler } from './components/Compiler/Compiler';\nimport { Header } from './components/Header/Header';\n\nconst App: React.FC = () => {\n    return (\n        <div className=\"App\">\n            <Header />\n            <Compiler />\n        </div>\n    );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport './index.scss';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}