- Sigo sin entender que son los parametros de los Store, pero no parece importar por ahora.
  - CREO que uno es el indice de en qué memoria
- No tengo ni idea de que hacer con los JUMPs
- Hay que meterle imports al modulo por cada funcion del runtime y la biblioteca estandar
- Hay que descubrir como guardar las strings en el segmento de datos
- Hay que pensar que prologos/epilogos agregar y como/donde.
  - Modificar el FP cuando se llama a una funcion
- push_function me da un CodeLocation. Hay que usar eso en el enviroment.


## Consulta

- Progreso general
- Arquitectura de WASM
- Nuestro uso de globals y locals. Modificaciones del tree.
- JUMPs
- Segmento de datos para strings. ¿Como es normalmente?
- Como seguimos despues a emitter.

 ## Alternativas:

- Ver casos de C con goto
- Modificar Tree
- Hacer analisis de dominancia de bloques


## Solucion?

- Una tabla label -> id
- bloque => [block, codigo bloque anterior, codigo, munch bloque siguiente, end]
- bloque => [block, codigo bloque anterior, codigo, end]
- funcion => loop con bloques anidados, ultimo bloque es br nextid, done tiene id del bloque
- JUMP => setear nextid
- CJUMP => if operacion then setear nextid a t else setear nextid a f
- tabla de label a id de datasegment para los strings

- Por qué tenemos el Global rv en vez de simplemente usar los valores de retorno de webassembly?


- meter las funciones en el env antes de traducir, onda typecheck
- elegir un mejor lugar para meter el segmento de datos (que offset usar)
- Como afecta el offset del segmento de datos al stack?
- imports de libreria estandar y run_time