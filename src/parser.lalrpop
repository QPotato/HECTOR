use std::str::FromStr;
use crate::ast::tigerabs::*;

grammar;

pub ASTr: Box<AST> = {
    <l: ASTr> "|" <r: CompAST> => {
        let no_pos_exp = Exp::If {
            test: l,
            then_: posed_exp(Exp::Int(1), 0, 0),
            else_: Some(r),
        };
        return posed_exp(no_pos_exp, 0, 0)
    },
    <l: ASTr> "&" <r: CompAST> => {
        let no_pos_exp = Exp::If {
            test: l,
            then_: r,
            else_: Some(posed_exp(Exp::Int(0), 0, 0)),
        };
        return posed_exp(no_pos_exp, 0, 0)
    },
    CompAST,
}

pub CompAST: Box<AST> = {
    <l:AddAST> <o:CompOp> <r:AddAST> => {
        let no_pos_exp = Exp::Op {left: l, oper: o, right: r};
        return posed_exp(no_pos_exp, 0, 0)
    },
    AddAST,
}

CompOp: Oper = {
    "=" => Oper::EqOp,
    "<" => Oper::LtOp,
    ">" => Oper::GtOp,
    ">=" => Oper::GeOp,
    "<=" => Oper::LeOp,
    "<>" => Oper::NeqOp,
}

AddAST: Box<AST> = {
    <l:AddAST> <o:AddOp> <r:MultAST> => {
        let no_pos_exp = Exp::Op {left: l, oper: o, right: r};
        return posed_exp(no_pos_exp, 0, 0)
    },
    MultAST,
}

AddOp: Oper = {
    "+" => Oper::PlusOp,
    "-" => Oper::MinusOp,
};

MultAST: Box<AST> = {
    <l:MultAST> <o:MultOp> <r:Term> => {
        let no_pos_exp = Exp::Op {left: l, oper: o, right: r};
        return posed_exp(no_pos_exp, 0, 0)
    },
    Term,
};

MultOp: Oper = {
    "*" => Oper::TimesOp,
    "/" => Oper::DivideOp,
};

Term: Box<AST> = {
    Num => {
        let no_pos_exp = Exp::Int(<>);
        return posed_exp(no_pos_exp, 0, 0)
    },
    "(" <ASTr> ")",
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};
