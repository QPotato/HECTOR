use std::str::FromStr;
use crate::ast::tigerabs::*;
use crate::ast::position::*;

grammar;

pub Expr: Box<Exp> = {
    "for" <var:Sym> ":=" <lo:IfThenExp> "to" <hi:IfThenExp> "do" <body: Expr> => {
        let no_pos_exp = _Exp::ForExp {
            var,
            escape: false,
            lo,
            hi,
            body,
        };
        return posed_exp(no_pos_exp, 0, 0);
    },
    "while" <test:Expr> "do" <body:Expr> => {
        let no_pos_exp = _Exp::WhileExp {
            test,
            body,
        };
        return posed_exp(no_pos_exp, 0, 0);
    },

    AssExp,
}

AssExp: Box<Exp> = {
    <v:VarEx> ":=" <e:IfThenExp> => {
        let no_pos_exp = _Exp::AssignExp {var: v, exp: e};
        return posed_exp(no_pos_exp, 0, 0);
    },
    IfThenExp,
}

IfThenExp: Box<Exp> = {
    "if" <test:IfThenElseExp> "then" <then_:IfThenElseExp> => {
        let no_pos_exp = _Exp::IfExp {
            test,
            then_,
            else_: None,
        };
        return posed_exp(no_pos_exp, 0, 0);
    },

    IfThenElseExp,
}

IfThenElseExp: Box<Exp> = {
    "if" <test:IfThenElseExp> "then" <then_:IfThenElseExp> "else" <else_:IfThenElseExp> => {
        let no_pos_exp = _Exp::IfExp {
            test,
            then_,
            else_: Some(else_),
        };
        return posed_exp(no_pos_exp, 0, 0);
    },
    BoolExp,
}

BoolExp: Box<Exp> = {
    <l: BoolExp> "|" <r: CompExp> => {
        let no_pos_exp = _Exp::IfExp {
            test: l,
            then_: posed_exp(_Exp::IntExp(1), 0, 0),
            else_: Some(r),
        };
        return posed_exp(no_pos_exp, 0, 0);
    },
    <l: BoolExp> "&" <r: CompExp> => {
        let no_pos_exp = _Exp::IfExp {
            test: l,
            then_: r,
            else_: Some(posed_exp(_Exp::IntExp(0), 0, 0)),
        };
        return posed_exp(no_pos_exp, 0, 0);
    },
    CompExp,
}

CompExp: Box<Exp> = {
    <l:AddExp> <o:CompOp> <r:AddExp> => {
        let no_pos_exp = _Exp::OpExp {left: l, oper: o, right: r};
        return posed_exp(no_pos_exp, 0, 0);
    },
    AddExp,
}

CompOp: Oper = {
    "=" => Oper::EqOp,
    "<" => Oper::LtOp,
    ">" => Oper::GtOp,
    ">=" => Oper::GeOp,
    "<=" => Oper::LeOp,
    "<>" => Oper::NeqOp,
}

AddExp: Box<Exp> = {
    <l:AddExp> <o:AddOp> <r:MultExp> => {
        let no_pos_exp = _Exp::OpExp {left: l, oper: o, right: r};
        return posed_exp(no_pos_exp, 0, 0);
    },
    MultExp,
}

AddOp: Oper = {
    "+" => Oper::PlusOp,
    "-" => Oper::MinusOp,
};

MultExp: Box<Exp> = {
    <l:MultExp> <o:MultOp> <r:Term> => {
        let no_pos_exp = _Exp::OpExp {left: l, oper: o, right: r};
        return posed_exp(no_pos_exp, 0, 0);
    },
    Term,
};

MultOp: Oper = {
    "*" => Oper::TimesOp,
    "/" => Oper::DivideOp,
};

Term: Box<Exp> = {
    "(" ")" => {
        let no_pos_exp = _Exp::UnitExp;
        return posed_exp(no_pos_exp, 0, 0);
    },
    "nil" => {
        let no_pos_exp = _Exp::NilExp;
        return posed_exp(no_pos_exp, 0, 0);
    },
    "break" => {
        let no_pos_exp = _Exp::BreakExp;
        return posed_exp(no_pos_exp, 0, 0);
    },
    Num => {
        let no_pos_exp = _Exp::IntExp(<>);
        return posed_exp(no_pos_exp, 0, 0);
    },
    <s:Str> => {
        let no_pos_exp = _Exp::StringExp(s);
        return posed_exp(no_pos_exp, 0, 0);
    },
    VarEx => {
        let no_pos_exp = _Exp::VarExp(<>);
        return posed_exp(no_pos_exp, 0, 0);
    },
    <s:Sym> "()" => {
        let no_pos_exp = _Exp::CallExp {
            func: s,
            args: vec![],
        };
        return posed_exp(no_pos_exp, 0, 0);
    },
    <s:Sym> "(" <f:CallFields> ")" => {
        let no_pos_exp = _Exp::CallExp {
            func: s,
            args: f,
        };
        return posed_exp(no_pos_exp, 0, 0);
    },
    "(" <Expr> ")",
};

CallFields: Vec<Box<Exp>> = {
    <e: Expr> "," <f: CallFields> => {
        let mut exps = vec![e];

        for ex in f {
            exps.push(ex);
        }

        return exps;
    },
    Expr => {
        vec![<>]
    }
}

VarEx: Var = {
    Sym => {
        return Var::SimpleVar(<>);
    },
    <v:VarEx> "[" <e:Expr> "]" => {
        let boxed_var = Box::new(v);
        return Var::SubscriptVar(boxed_var, e);
    },
    <v:VarEx> "." <s:Sym> => {
        let boxed_var = Box::new(v);
        return Var::FieldVar(boxed_var, s);
    },
}

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};

Sym: String = {
    r"[_a-zA-Z][_a-zA-Z0-9]*" => String::from_str(<>).unwrap()
}

Str: String = {
    r#""(?:[^\\"\\\\]*(?:\.[^\\"\\\\]*)*)""# => String::from_str(<>).unwrap()
}

DecEx: Dec = {
    "type" <name:Sym> "=" <ty:TyEx> => {
        TypeDec(vec![])
    }
}

TyEx: Ty = {
    Sym => NameTy(<>)

    "{" <tyfields: TyFieldsEx> "}" => RecordTy(tyfields),
    "{" "}" => RecordTy(vec![]),

    "array" "of" <s: Sym> => ArrayTy(s),
}

TyFieldsEx: Vec<Box<Field>> = {
    <new:TyFieldEx> "," <fields:TyFieldsEx> => {
        let mut tys = vec![Box::new(new)];

        for ex in f {
            exps.push(ex);
        }
        return tys;
    },
    TyFieldEx => {
        vec![Box::new(<>)]
    }
}

TyFieldEx: Field {
    <name: Sym> ":" <tyName: Sym> => {
        Field {
            name,
            escape: false,
            ytp: NameTy(tyName),
        }
    }
}
